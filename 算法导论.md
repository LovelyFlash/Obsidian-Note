# 第一部分 **基础知识**

## 第 1 章 算法在计算中的运用

### 1.1 算法

#### 定义

非形式地说，**算法** (algorithm) 就是任何良定义的计算过程，该过程取某个值或值的集合作为**输入**并产生某个值或值的集合作为**输出**。

若对每个输入实例算法都以正确的输出停机，则称该算法是**正确的**，并称正确的算法**解决了**给定的计算问题。

算法问题所共有的两个特征：

1. 存在许多候选解，但绝大多数候选解都没有解决手头的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。
2. 存在实际应用。

#### NP 完全问题

- 对于 NP 完全问题，是否存在有效算法是未知的。
- 如果任何一个 NP 完全问题存在有效算法，那么所有 NP 完全问题都存在有效算法。
- 有儿个 NP 完全问题类似千（但又不完全同千）一些有着已知有效算法的问题。

### 1.2 作为一种技术的算法

#### 效率

为求解相同问题而设计的不同算法在效率方面常常具有显著的差别。这些差别可能比由于硬件和软件造成的差别要重要得多。

#### 算法与其他技术

我们应该像计算机硬件一样把算法看成是一种技术。整个系统的性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法。

## 第 2 章 算法基础

### 2.1 插入排序

#### 简单类比

![[算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library).pdf#page=23&rect=260,39,458,235|算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library), p.23]] 插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如图 2-1 所示。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。

#### 循环不变式与插入排序的正确性

循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：

- **初始化**：循环的第一次迭代之前，它为真。
- **保持**：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- **终止**：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

### 2.2 分析算法

#### 插入排序算法的分析

**输入规模**的最佳概念依赖于研究的问题。一个算法在特定输入上的**运行时间**是指执行的基本操作数或步数。

#### 最坏情况与平均情况分析

我们往往集中于只求最坏情况运行时间，即对规模为 n 的任何输入，算法的最长运行时间。下面给出这样做的三点理由：

- 一个算法的最坏情况运行时间
- 给出了任何输入的运行时间的一个上界。知道了这个界， 就能确保该算法绝不需要更长的时间。我们不必对运行时间做某种复杂的猜测并可以期望它不会变得更坏。
- 对某些算法，最坏情况经常出现。例如，当在数据库中检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况会经常出现。在某些应用中，对缺失信息的检索可能是频繁的。
-  " 平均情况 " 往往与最坏情况大致一样差。假定随机选择 n 个数并应用插入排序。需要多长时间来确定在子数组 A[1…j-] 的什么位置插入元素 A[j]? 平均来说， A[1…j-1] 中的一半元素小于 A[j], 一半元素大于 A[j] 。所以，平均来说，我们检查子数组 A[1… j -1] 的一半，那么 $t_j$ 大约为 $\frac{j}{2}$。导致的平均情况运行时间结果像最坏情况运行时间一样，也是输入规模的一个二次函数。
在某些特定情况下，我们会对一个算法的**平均情况**运行时间感兴趣

#### 增长量级

现在我们做出一种更简化的抽象：即我们真正感兴趣的运行时间的增长率或增长量级。所以我们只考虑公式中最重要的项（例如， $an^2$),因为当 n 的值很大时，低阶项相对来说不太重要。我们也忽略最重要的项的常系数，因为对大的输入，在确定计算效率时常量因子不如增长率重要。对千插入排序，当我们忽略低阶项和最重要的项的常系数时，只剩下最重要的项中的因子 $n^2$。我们记插入排序具有最坏情况运行时间 $\Theta\left(n^2\right)$(读作 "theta n 平方 ")。

### 2.3 设计算法

#### 2.3.1 分治法

分治模式在每层递归时都有三个步骤：

- **分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。
- **合并**这些子问题的解成原问题的解。

##### 归并排序

**归井排序**算法完全遵循分治模式。直观上其操作如下：
- **分解**：分解待排序的 n 个元素的序列成各具 n/2 个元素的两个子序列。
- **解决**：使用归并排序递归地排序两个子序列。
- **合井**：合并两个已排序的子序列以产生已排序的答案。
![[算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library).pdf#page=34&rect=76,461,414,674|算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library), p.34]]

#### 2.3.2 分析分治算法

假设把原问题分解成 $a$ 个子问题，每个子问题的规模是原问题的 $1/b$。 （对归并排序， $a$ 和 $b$ 都为 2, 然而，我们将看到在许多分治算法中，$a \neq b$ 。为了求解一个规模为 $n/b$ 的子问题，需要 $T(n/b)$ 的时间，所以需要 $aT(n/b)$ 的时间来求解 $a$ 个子问题。如果分解问题成子问题需要时间 $D(n)$, 合并子问题的解成原问题的解需要时间 $C(n)$, 那么得到递归式：

$$
\large
T(n) = \begin{cases} \Theta (1) & \text(若n \leq c) \\
aT(n/b)+D(n)+C(N) & \text(其他)
\end{cases}
$$

##### 归井排序算法的分析

下面我们分析建立归并排序 n 个数的最坏情况运行时间 T(n) 的递归式。归并排序一个元素需要常量时间。当有 $n>1$ 个元素时，我们分解运行时间如下：

- **分解**：分解步骤仅仅计算子数组的中间位置，需要常量时间，因此， $D(n)=\Theta (l)$ 。
- **解决**：我们递归地求解两个规模均为 $n/2$ 的子问题，将贡献 $2T(n/2)$ 的运行时间。
- **合井**：我们已经注意到在一个具有 $n$ 个元素的子数组上过程 MERGE 需要 $\Theta(n)$ 的时间，所以 $C(n)=\Theta(n)$ 。
归并排序的最坏情况运行时间 $T(n)$ 的递归式：

$$
\large
T(n)=\begin{cases} 
\Theta(1) & \text(若n=1) \\
2T(n/2)+\Theta(n) & \text(若n>1)
\end{cases}
$$

在第 4 章，我们将看到 " 主定理 "，可以用该定理来证明 $T(n)$ 为 $\Theta(n \lg n)$, 其中 $\lg{n}$ 代表 $\log_{2}{n}$ 。

![[算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library).pdf#page=35&rect=37,98,450,439|算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library), p.35]]

为了计算递归式表示的总代价，我们只要把各层的代价加起来。递归树具有 $\lg{n}+1$ 层，每层的代价均为 $cn$, 所以总代价为 $cn(\lg(n)+1) = cn \lg(n)+cn$ 。忽略低阶项和常量 $c$ 便给出了期望的结果 $\Theta(n\lg{n})$ 。

## 第 3 章 函数的增长

当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的渐近效率。也就是说，我们关心当输入规模无限增加时，在极限中，算法的运行时间如何随着输入规模的变大而增加。通常，渐近地更有效的某个算法对除很小的输入外的所有情况将是最好的选择。

本章给出几种标准方法来简化算法的渐近分析。下一节首先定义几类＂渐近记号 "，其中，我们已经见过的一个例子是 $\Theta$ 记号。然后，我们给出贯穿本书使用的儿种记号约定。最后，我们回顾一下在算法分析中常见的若干函数的行为。

### 3.1 渐进记号

#### 渐近记号、函数与运行时间

即使我们使用渐近记号来刻画算法的运行时间，我们也需要了解意指***哪个***运行时间。有时我们对最坏情况运行时间感兴趣。然而，我们常常希望刻画任何输入的运行时间。换句话说，我们常常希望做出一种综合性地覆盖所有输入而不仅仅是最坏情况的陈述。我们将看到完全适合刻画任何输入的运行时间的渐近记号。

##### $\Theta$ 记号

对一个给定的函数 $g(n)$, 用 $\Theta(g(n))$ 来表示以下***函数的集合***：

$$
\Theta(g(n))=\{ f(n):存在正常量c_1、c_2和n_0，使得对所有n\geq n_0，有0 \leq c_{1}g(n) \leq f(n) \leq c_{2}g(n) \}
$$

若存在正常量 $c_1$ 和 $c_2$，使得对于足够大的 $n$，函数 $f(n)$ 能 " 夹入 " $c_{1}g(n)$ 和 $c_{2}g(n)$ 之间，则 $f(n)$ 属于集合 $\Theta(g(n))$。

![[算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library).pdf#page=40&rect=32,344,456,561|算法导论 第三版 可复制 有目录 (Thmos.H.Cormen ,Charles E. Leiserson etc.) (Z-Library), p.40]]

对所有 $n \geq n_0$。，函数 $f(n)$ 在一个常量因子内等于 $g(n)$。我们称 $g(n)$ 是 $f(n)$ 的一个**渐近紧确界** (asymptotically tight bound) 。

##### $O$ 记号

$\Theta$ 记号渐近地给出一个函数的上界和下界。当只有一个**渐近上界**时，使用 $O$ 记号。对于给定的函数 $g(n)$, 用 $O(g(n))$( 读作 " 大 $Og(n)$", 有时仅读作 "$Og(n)$") 来表示以下函数的集合：

$$
\large
O(g(n)) = \{ f(n): 存在正常量 c 和 n_0 , 使得对所有 n\geq n_0 ,有 0\leq f(n)\leq cg(n) \}
$$

##### $\Omega$ 记号

正如 $O$ 记号提供了一个函数的渐近上界， $\Omega$ 记号提供了渐近下界。对于给定的函数 $g(n)$ 用 $\Omega(g(n))$( 读作 " 大 $\Omega g(n)$", 有时仅读作 "$\Omega g(n)$") 来表示以下函数的集合：

$$
\large
\Omega(g(n)) = \{ f(n): 存在正常量 c 和 n_0 , 使得对所有 n\geq n_0 , 有 0\leq f(n)\leq cg(n) \}
$$

##### 等式和不等式中的渐近记号

一般来说，当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。例如，公式 $2n^2+3n+1=2n^2+\Theta(n)$ 意指 $2n^2 +3n+ 1 =2n^2 + f(n)$, 其中 $f(n)$ 是集合 $\Theta(n)$ 中的某个函数。在这个例子中， 假设 $f(n)=3n+1$, 该函数确实在 $\Theta(n)$ 中。

按这种方式使用渐近记号可以帮助消除一个等式中无关紧要的细节与混乱。例如，在第 2 章中，我们把归并排序的最坏情况运行时间表示为递归式

$$
T(n)=2T(n/2)+\Theta(n)
$$

如果只对 $T(n)$ 的渐近行为感兴趣，那么没有必要准确说明所有低阶项，它们都被理解为包含在由项 $\Theta(n)$ 表示的匿名函数中。

一个表达式中匿名函数的数目可以理解为等于渐近记号出现的次数。例如，在表达式 $\sum\limits_{i=1}^{n} O(i)$ 中，只有一个匿名函数 (一个 $i$ 的函数)。因此，这个表达式不同于 $O(1)+O(2)+…+O(n)$，实际上后者没有一个清晰的解释。

##### $o$ 记号

我们使用 $o$ 记号来表示一个非渐近紧确的上界。形式化地定义 $o(g(n))$ （读作 " 小 $og(n)$") 为以下集合：

$$
o(g(n)) = \{f(n) : 对任意正常量 c>0, 存在常量 n_0>0, 使得对所有 n\geq n_0, 有 0\leq f(n) < cg(n)\}
$$

##### $\omega$ 记号

$\omega$ 记号和 $\Omega$ 记号的关系类似于 $o$ 记号和 $O$ 记号的关系。我们使用 $\omega$ 记号来表示一个非渐进紧确的下界。定义它的一种方式是

$$
f(n) \in \omega(g(n))当且仅当g(n) \in o(f(n))
$$

然而，我们形式化地定义 $\omega(g(n))$(读作 " 小 $\omega g(n)$") 为以下集合

$$
\omega(g(n)) = \{f(n) : 对任意正常量 c>0, 存在常量 n_0>0, 使得对所有 n\geq n_0, 有 0\leq cg(n)<f(n)\}
$$

例如，$n^2/2=\omega(n)$，但是 $n^2/2 \neq \omega(n^2)$。关系 $f(n)=\omega(g(n))$ 蕴含着

$$
\lim_{n \to \infty} \frac{f(n)}{g(n)}=\infty
$$

也就是说，如果这个极限存在，那么当 $n$ 趋于无穷时， $f(n)$ 相对于 $g(n)$ 来说变得任意大了。
