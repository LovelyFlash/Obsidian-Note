---
tags:
  - 课程/CPP程序设计
title: 类的构造与析构
date created: 星期六, 十月 18日 2025, 10:49:29 晚上
date modified: 星期四, 十月 23日 2025, 9:06:19 晚上
---

# 1 构造函数

## 1.1 基础

构造函数的分类：
- 无参数构造函数
- 以简单类型为参数的构造函数
- 以对象为参数的构造函数（<font color="#c0504d">复制构造</font>）
- 以临时对象为参数的构造函数（<font color="#c0504d">移动构造</font>）

特点：
- 构造函数可以有多个，也可以不定义，支持重载；
- 函数名与类名相同，无返回类型，智只能自动调用；
- 并<font color="#c0504d">不负责申请对象本身的空间</font>，只做空间的初始化操作，或申请体外空间。

## 1.2 初始化

初始化分为<font color="#d83931">在构造函数体前初始化</font>与<font color="#d83931">在构造函数体中初始化</font>，还有<font color="#d83931">定义时赋值</font>（其原理和赋值流程等于在构造函数体前初始化）。
```C++
ClassName::ClassName(parameter1, parameter2, argument_for_member1, arg1...)
    : member1(argument_for_member1),
      member2(argument_for_member2),
      classmenber(arg1, arg2, ...)
      // 在构造函数体前初始化
{
    // 在构造函数体中初始化：这里可以执行其他逻辑，但不能再初始化上述成员
}
```
<font color="#d83931">只读成员</font>、<font color="#d83931">引用成员</font>、<font color="#d83931">对象成员</font>需要在构造函数体前初始化。`const` 常量和 `&` 引用必须在定义时赋初值，故无法在构造函数体中赋值；类对象无法手动调用初始化函数，故需要在构造函数体前使用其初始化参数表进行初始化。

定义对象时，会自动调用构造函数进行初始化。初始化的顺序为类定义中声明的先后次序。若含有只读成员、引用成员、对象成员，除非定义时就初始化，否则一定要有构造函数。

## 1.3 构造函数种类

### 1.3.1 默认构造函数

在<font color="#4f81bd">未定义任何特殊函数时</font>（构造函数、赋值运算符、析构函数），编译器提供<font color="#4f81bd">默认的构造函数</font>：
- 无参构造函数：定义数据成员时给出了初值，会使用该函数完成初始化；
- 以有址引用为参数的构造函数：使用浅拷贝；
- 以无址引用为参数的构造函数：对于类类型的成员，优先使用其移动构造函数，否则使用赋值构造函数；对于基本类型或指针，直接复制其值。

定义了构造函数后，则不再提供默认构造函数。如果仍然希望有默构造函数则使用 `ClassName() = default;`、`ClassName(const ClassName &A) = default;`、`ClassName(ClassName &&A) = default;`。
同理，如果想要一定不使用默认构造函数，则使用关键字 `delete`。

### 1.3.2 复制构造

编译器也会提供默认的以对象 [[Study/C++程序设计/引用变量|有址引用]] 为参数的构造函数，使用的是<font color="#d83931">浅拷贝</font>。即简单的将所有内容拷贝，例如，有指针指向体外空间时，简单的拷贝地址，导致两个对象的成员指针指向同一片地址。
为实现<font color="#d83931">深拷贝</font>，需要自己编写以对象 [[Study/C++程序设计/引用变量|有址引用]] 为参数的构造函数。
```C++
ClassName(const ClassName &a) {
	// 深拷贝
}
```
加 [[const修饰符|const]] 的原因：可以同时兼容<font color="#c0504d">常量对象</font>、<font color="#c0504d">临时对象</font>、普通对象的拷贝。

### 1.3.3 移动构造

也会默认提供。指的是 [[Study/C++程序设计/引用变量|无址引用]]（临时的、没有名称、不能取地址、只能出现在赋值运算符右侧的表达式的引用）为参数的构造函数。直接接管临时（局部）对象指针指向的空间，而不用进行拷贝。
```C++
MyClass(MyClass&& other) noexcept
        : name(std::move(other.name)), p(other.p)
    {
		   other.p = nullptr;
        // ...
    }µµ
```
对于指针，可以对其进行浅拷贝（复制内存地址），将原地址的所有权进行移动，即可完成窃取；对于简单类型，如 `int` ，直接进行复制是最高效的做法；而对于复杂类型，如 `string`，使用 `std::move` 进行窃取，否则会进行深拷贝。

# 2 析构函数

在一个对象 [[深入理解变量|生命周期]] 结束时，会自动调用析构函数。析构函数可以释放指针成员指向的体外空间。

特点：
- 析构函数只能有一个，函数名为 `~ClassName`；
- 无返回值，无参数；
- 可以手动调用。
