---
tags:
  - 课程/CPP程序设计
title: 运算符重载
date created: 星期日, 十月 19日 2025, 12:47:03 凌晨
date modified: 星期二, 十月 21日 2025, 1:22:28 下午
---

# 1 运算符概述

设有 A 类的对象 a、b、c，要完成赋值操作 ``a.assign(b);``。``assign`` 的定义形式应该是 ``A & assign(const A &t);``。这样支持临时对象赋值与连续赋值。

类似的，可以使用赋值运算符函数 ``A & operator=(const A &t);``。
```C++
MAT& MAT::operator=(const MAT&a) { 
	cout << “assign operation ...” << endl;
	if (this == &a) 
		return *this;
	r = a.r;
	c = a.c; 
	if(e) 
		delete e;
	e = newint[r * c];
	memcpy(e, a.e, r * c * sizeof(int));
	return *this;
}
```
为提高效率，还需提供移动赋值函数 ``A & operator=(A &&t);``

```C++
class MAT {
	int* e; //指向所有整型矩阵元素的指针
	intr, c;
public:
	MAT(intr, intc); //矩阵定义
	MAT(constMAT& a); //深拷贝构造
	MAT(MAT&& a);
	MAT&operator=(constMAT& a); //深拷贝赋值运算 
	MAT& operator=(MAT&& a); //移动赋值运算
	MAT&operator+=(constMAT& a);//“+=”运算
	MAT& operator-=(constMAT& a);//“-=”运算
	MAT& operator*=(constMAT& a);
};
```

运算符的分类：
```C++ 
// 纯单目运算符
！、～、sizeof、new、delete、++、-- 

// 纯双目运算符
[ ]、->、%、=、/

// 三目运算符
? :

// 单目或双目运算符
+、-、&、*  // +、-用来表示正负时为单目

// 多目运算符
（ ） // 函数参数表
```

```C++
// 左值运算符：运算结果为左值
（前置）++、--，=、+=、-=、*=、&=

// 右值运算符：运算结果为右值
+、-、%、/、*、（后置）++、--
```

```C++
// 算数运算
+、-、*、/、%

// 关系运算
==、!=、<、>、<=、>=

// 逻辑运算
||、&&、!

// 单目运算
+、-、*、&

// 自增自减
++、--

// 位运算
|、&、~、^、<<、>>

// 赋值运算
=、+=、-=、*=、/=、&=

// 空间申请与释放
new、delete、new[]、delete[]

// 其他运算
()、[]、->、,
```

不能重载的情况：
```C++
// 不能重载
sizeof、.、.*、::、? 、:

// 不能重载为静态函数成员，可以重载为普通函数、实例函数成员
+、-、*、/、+=、*=

// 不能重载为普通函数、静态函数成员，可重载为实例函数成员
＝、->、( )、[ ]

// 不能重载为类中的实例成员函数，可重载为普通函数、静态函数成员
new、delete
```

# 2 运算符重载

一定要注意 `const` 和 `&` 的用法。见 [[Study/C++程序设计/引用变量]]，[[const修饰符]]。

## 2.1 重载赋值运算符 `` = ``、` += `、` -= ` 等：

编译器提供的默认的赋值运算包含浅拷贝和移动赋值运算符，与 [[类的构造与析构|默认构造函数]] 类似。

重载 ` = ` 赋值运算：类似于 [[类的构造与析构|类的构造]]。<font color="#d83931">但是要释放原本的空间。</font>
为什么要返回引用？这样支持连续赋值，以及对其的进一步运算。

若进行了 `a = a` 操作，不会出现异常提示，但结果不正确。
需要加语句 `if (this == &a) return *this;`。

```C++
// 恰当定义方法: ClassName & operator=(const ClassName &obj)； 
MAT& MAT::operator=(const MAT&a) { //深拷贝赋值运算
	cout << “assign operation ...” << endl;
	if (this == &a) 
		return *this;
	r = a.r;
	c = a.c; 
	if(e) 
		delete e;
	e = newint[r * c];
	memcpy(e, a.e, r * c * sizeof(int));
	return *this;
}
```

同时定义移动赋值运算的优点是：
如果进行了 `a = b + c` 操作，`b + c` 返回临时对象，进行移动赋值运算可以提高性能。

```C++
// 恰当定义方法: ClassName & operator=(ClassName &&obj)；
MAT& MAT::operator=(MAT && a) { //移动赋值运算 
	if (this == &a) 
		return *this; 
	cout << "moving assign operation ..." << endl; 
	r = a.r; 
	c = a.c; 
	if (e) 
		delete e; 
	e = a.e; 
	a.e = nullptr; 
	return *this;
}
```
重载 `+=`、`-=`、`*=`：定义类似深拷贝。
``ClassName& operator +=(const ClassName&obj);``

## 2.2 重载 ` + `、` - ` 等：

``ClassName operator +(const ClassName & obj) const;``

```C++
class STRING {
private: 
	char *s;
public:
	STRING(constchar *s) {
		s=new char[strlen(str)+1];
		strcpy(s,str);
	}
};
```

## 2.3 重载 ` [ ] `：

```C++
char & STRING::operator [](int i) {
	return *(s+i); 
}
```

重载普通函数，声明为 [[友元]]：
关键字 `friend`，将普通函数声明为一个类的友元后，该函数可以访问该类的私有成员和保护成员。
重载的普通运算符成员函数可定义为 [[虚函数]]。

## 2.4 重载 ` ++ `、` -- `：

前置运算返回左值，后置运算返回右值（本质上是拷贝一个副本，然后原变量自增、自减）。
```C++
A &operator++( ){ a++; return *this; }//单目，前置运算
A operator++(int){ return A(a++); }//加 int 参数以事编译器识别，后置运算
```

## 2.5 重载 ` -> `：

**工作原理（链式调用）：**
当使用 ⁠`obj->member` 这样的语法时，编译器会执行一个特殊的解析过程：
1. 编译器首先调用 `obj.operator->()`。
2. 如果 ⁠`obj.operator->()` 返回一个原始指针 `⁠ptr` (例如 ⁠`MyClass`)：那么表达式就变成了 `⁠ptr->member`，然后像普通指针一样访问 `⁠member`。
3. 如果 `⁠obj.operator->()` 返回另一个对象 `⁠proxy_obj` (这个 `⁠proxy_obj` 也重载了 `⁠operator->`)：那么编译器会<font color="#d83931">递归地</font>再次调用 `⁠proxy_obj.operator->()`，<font color="#d83931">直到最终返回一个原始指针为止</font>。这个过程被称为<font color="#d83931">链式调用</font>。

```C++
struct A{
	int a;
	A(int x) { a=x; }
};

class B{
	A x;
public:
	A *operator ->( ){ return &x; }; // 重载->
	B(int v):x(v) { }
}b(5);

void main(void){
	int i=b->a; //等价于下一条语句，i=b.x.a=5
	i=b.operator ->( )->a; //i=b.x.a=5
	i =( b.operator ->( )) ->a;
	i=*(b.operator->( )).a; //i = b.operator ->( )->a
}
```

# 3 强制类型转换

强制类型转换的格式为 `operator class1()；`，无参数，无返回值，用于将 `ClassName` 转化为 `class1`。类型转换的结果通常为<font color="#d83931">右值</font>，也不应当修改当前被转换对象。
```C++
class COMPLEX { 
	double r, v; 
public: 
	COMPLEX(double r1, double v1=0) { // double 转换为 complex
		r=r1; v=v1; 
	} // 构造函数可以用于强制类型转换
	operator double() { // conplex 转换为 double
		return r; 
	} // 强制类型转换函数： operator 类型(……)
	COMPLEX operator+(const COMPLEX &c)const; 
	COMPLEX operator**-**(const COMPLEX &c)const; 
};
```

单参数的构造函数具备类型转换作用，用于将其他类型转化为当前定义的类型，能自动将参数类型的值转换为要构造的类型。关键字 `explicit`，用来<font color="#d83931">禁止隐式类型转换</font>。
用其修饰单参数构造函数（或多参数，但提供缺省值）时，禁止其作为类型转换。
`String s("hello")` 为显示构造；`String s = "hello"` 为隐式转换。

# 4 重载 new 和 delete

`new` 和 `delete` 可以重载为<font color="#c0504d">普通函数</font>和<font color="#c0504d">静态函数成员</font>。

```C++
extern void * operator new(unsigned bytes); 
extern void operator delete(void *ptr);
```

使用 `ClassName &p = *new ClassName(arg);` 后，一定要使用 `delete &p;` 析构并释放内存。
更推荐的做法是使用<font color="#d83931">智能指针</font>：`std::shared_ptr<ClassName> p = std::make_shared<ClassName>(arg);`，编译器会自动管理，在生命周期结束后释放。
