# 1 什么是友元？

在 C++ 中，**友元 (Friend)** 是一种特殊的机制，它允许一个**非成员函数**、**另一个类**，或者**另一个类的特定成员函数**，访问声明它为友元的类的 `private` 和 `protected` 成员。

友元是 C++ 封装原则的一个**受控的例外**。它允许你选择性地“打破”封装，为特定的外部实体提供对类内部实现的访问权限。

# 2 如何声明友元？

友元通过在类定义内部使用 `friend` 关键字来声明。

1. **友元函数 (Friend Function)**
将一个**非成员函数**声明为友元。这个函数可以是全局函数，也可以是另一个类的成员函数（但不是当前类的成员函数）。

  ```C++
#include <iostream>

class MyClass {
private:
    int privateData;
public:
    MyClass(int data) : privateData(data) {}
    // 声明一个全局函数 printPrivateData 为 MyClass 的友元
    friend void printPrivateData(const MyClass& obj);
};

// 友元函数的定义 (它不是 MyClass 的成员函数)
void printPrivateData(const MyClass& obj) {
    // 作为友元，它可以访问 MyClass 的私有成员
    std::cout << "Friend Function: Accessing privateData = " << obj.privateData << std::endl;
}
 
// int main() {
//     MyClass obj(10);
//     printPrivateData(obj); // 输出: Friend Function: Accessing privateData = 10
//     return 0;
// }
  ```
      

2. **友元类 (Friend Class)**
将**另一个类**声明为友元。被声明为友元的类中的**所有成员函数**都可以访问声明友元类的 `private` 和 `protected` 成员。

  ```C++
// 需要前向声明 OtherClass，因为 MyClass 在定义 OtherClass 之前就引用了它

class OtherClass;
class MyClass {
private:
    int privateData;
public:
    MyClass(int data) : privateData(data) {}
    // 声明 OtherClass 为 MyClass 的友元
    friend class OtherClass;
};

class OtherClass {
public:
    void accessMyClassPrivate(const MyClass& obj) {
        // 作为友元类，OtherClass 的成员函数可以访问 MyClass 的私有成员
        std::cout << "Friend Class: OtherClass accessing privateData = " 
			<< obj.privateData << std::endl;
    }
    void anotherOtherFunction(const MyClass& obj) {
        // 这个函数也是 OtherClass 的成员，所以也能访问 MyClass 的私有成员
        std::cout 
	        << "Friend Class: Another OtherClass function accessing privateData = " 
	        << obj.privateData << std::endl;
    }
};

// int main() {
//     MyClass obj(20);
//     OtherClass otherObj;
//     otherObj.accessMyClassPrivate(obj); // 输出: Friend Class: OtherClass accessing privateData = 20
//     otherObj.anotherOtherFunction(obj); // 输出: Friend Class: Another OtherClass function accessing privateData = 20
//     return 0;
// }
```
   
3. **友元成员函数 (Friend Member Function)**
将**另一个类的特定成员函数**声明为友元。这是最精细的友元控制方式，只有被声明的那个成员函数才能访问私有和保护成员。

  ```C++
// 需要前向声明 OtherClass
class OtherClass;
class MyClass {
private:
    int privateData;
public:
    MyClass(int data) : privateData(data) {}
    // 声明 OtherClass 的某个成员函数 accessMyClassPrivate 为 MyClass 的友元
    friend void OtherClass::accessMyClassPrivate(const MyClass& obj);
};

class OtherClass {
public:
    void accessMyClassPrivate(const MyClass& obj) {
        // 作为友元成员函数，它可以访问 MyClass 的私有成员
        std::cout << "Friend Member Function: OtherClass::accessMyClassPrivate accessing privateData = " 
	        << obj.privateData << std::endl;
    }
    void anotherOtherFunction(const MyClass& obj) {
        // 这个函数不是友元，所以不能访问 MyClass 的私有成员
        // std::cout << obj.privateData << std::endl; // 错误：'int MyClass::privateData' is private
    }
};

// int main() {
//     MyClass obj(30);
//     OtherClass otherObj;
//     otherObj.accessMyClassPrivate(obj); // 输出: Friend Member Function: OtherClass::accessMyClassPrivate accessing privateData = 30
//     otherObj.anotherOtherFunction(obj); // 编译错误
//     return 0;
// }
```

  
# 3 友元的作用和目的

友元的主要作用是**提供受控的访问权限，以实现特定的设计需求**。它在以下场景中特别有用：

1. **运算符重载 (Operator Overloading)：**

▪ 这是友元最常见的用途之一，尤其对于**二元运算符**（如 +, -, ）和**流插入/提取运算符** (<<, >>)。

▪ 当运算符的**左侧操作数不是类的对象**时（例如 std::cout << myObject;），或者当运算符需要**对称地访问两个操作数的私有成员**时，友元函数是必要的。

▪ **优势：** 允许隐式类型转换，使得自定义类型与内置类型的操作行为更一致。

2. **辅助函数 (Helper Functions)：**

▪ 当一个函数与某个类紧密相关，需要访问其私有成员，但从语义上讲，它不适合作为该类的成员函数时，可以将其声明为友元。

▪ **示例：** 一个用于打印类内部所有私有状态的调试函数。

3. **相关类之间的紧密协作 (Closely Related Classes)：**

▪ 在某些情况下，两个类之间存在非常紧密的逻辑关系，以至于它们需要频繁且深入地访问彼此的私有成员。例如，一个容器类（如 LinkedList）可能需要直接操作其节点类（Node）的私有指针。

▪ **优势：** 友元可以简化代码并提高效率，避免通过大量的公共 getter/setter 方法来间接访问。

4. **迭代器 (Iterators)：**

▪ 迭代器通常需要访问它们所遍历的容器的私有数据，但它们本身不是容器的成员。


# 4 友元的缺点和注意事项**

尽管友元提供了灵活性，但它也带来了一些潜在的问题，因此应该**谨慎使用**：

1. **破坏封装性：** 友元是封装原则的“后门”。过度使用友元会导致代码的耦合度增加，使得类内部的实现细节暴露给外部，降低了代码的可维护性和可扩展性。

2. **增加复杂性：** 友元使得类的接口不再仅仅由其公共成员定义，还需要考虑友元函数或友元类，增加了理解和维护的难度。

3. **单向性：** 友元关系是单向的。如果 A 是 B 的友元，不意味着 B 也是 A 的友元。

4. **不继承：** 友元关系不能被继承。如果基类声明了友元，其派生类不会自动成为友元。

5. **不传递：** 友元关系不具有传递性。如果 A 是 B 的友元，B 是 C 的友元，不意味着 A 是 C 的友元。

**最佳实践：**

• **优先使用公共接口：** 总是优先考虑通过类的公共接口（公共成员函数，如 getter/setter）来访问私有数据。

• **最小化友元范围：** 如果确实需要友元，应尽可能使用**友元成员函数**，而不是整个友元类，以最小化对封装的破坏。

• **仅在必要时使用：** 只有在没有更好的替代方案，且友元能显著简化设计或提高性能时才考虑使用。