---
title: 对象指针与内存管理
date created: 星期四, 十月 23日 2025, 9:08:28 晚上
date modified: 星期五, 十月 24日 2025, 8:56:53 早上
---

# 1 对象指针

可以通过对象指针建立一个链表。

![[对象指针-1.png|450]]

```C++
class StudentList {
	StudentNode *head;
public:
	insertIntoList(StudentNode *p);
};

class StudentNode {
Student s;
StudentNode *next;
};
```

**如何产生指针指向的对象？**
`malloc` 只能申请空间，无法初始化；而类的构造函数只能自动调用，无法手动调用。
于是，引入了 `new` 和 `delete` 运算符。

# 2 `new` 和 `delete` 运算符与内存管理

`new`、`delete` **对比** `malloc`、`free` **：**
- `malloc` 负责申请空间，`free` 负责释放空间；
- `new` 负责申请空间<font color="#4f81bd">并自动调用构造函数进行初始化</font>，`delete`<font color="#4f81bd">自动调用析构函数</font>并释放空间（注意顺序）。

**注意：**
- 如果使用 `new` 分配了内存，但没有使用 `delete` 释放，就会导致内存泄漏。在复杂的程序中，确保每一个 `new` 都有对应的 `delete` 可能会很困难，尤其是在异常发生时。
- 当指针指向的内存已经被释放，但指针仍然保留着原来的地址，这时就产生了悬空指针。如果后续通过这个悬空指针访问内存，会导致未定义行为。
- 同一个内存块被释放两次（重复释放），这会导致运行时错误。
- 所有权不明确：当多个指针指向同一个对象时，很难确定哪个指针负责释放内存。这可能导致重复释放或者内存泄漏。

**用引用代替指针的方法：**
```C++
A &p = *new A(10);
delete &p;
```

## 2.1 简单类型的内存管理

此时 `new`、`delete` 与 `malloc`、`free` 等同，可混用。

```C++
#include <malloc.h>
char *remark;

remark = (char *)malloc(15); // 使用 malloc
remark = new char[15]; // 使用 new

free(remark); // 使用 free
delete [ ]remark; // 使用 delete
```

## 2.2 单个对象的内存管理

**语法：**
`new Type;` 或 `new Type(args)；`
`delete pointer;`

**示例：**
```C++
int *p = new int;
ARRAY *q = new ARRAY;
delete p;
delete q;

int *p = new int(10);
ARRAY *q = new ARRAY(5,7);
```

# 2.3 对象数组的内存管理

**语法：**
`new Type[size];` 创建一个对象数组，大小为 `size`。
`delete [] pointer；` 指针指向任意维度的数组时使用，对所有元素自动调用析构函数。
**添加构造参数的方法：**
```C++
new Type[size]{{第0个对象的构造参数}，
			   {第1个对象的构造参数}，…}；
```

**示例：**
```C++
ARRAY *qa = new ARRAY[5]; // 创建了一个数组，其中包含 5 个 ARRAY
ARRAY *qb = new ARRAY[10]{{3,4},ARRAY(5,6),{…}…};
delete [] qa;
delete [] qb;
```
