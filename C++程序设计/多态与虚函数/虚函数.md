---
tags:
  - 课程/CPP程序设计
title: 虚函数
date created: 星期六, 十月 18日 2025, 4:55:45 下午
date modified: 星期一, 十月 20日 2025, 11:48:21 晚上
---

虚函数是 C++ 实现**运行时多态**的核心机制。它是连接继承和多态的桥梁。

# 1 虚函数的定义

虚函数是在 [[继承|基类]] 中声明的，用 `⁠virtual` 关键字修饰的成员函数。

**定义方式：**（在体外实现时，不需要加 `virtual`）
```C++
class Base {
public: // 声明为 public 或 protedted 都可以
    virtual ReturnType functionName(Parameters); // 声明为虚函数
    // ...
};
```
接下来，在派生类中定义同名函数即可，添加 `virtual` 与否都是虚函数。

可以在末尾加上关键字 `override`。
- **目的：** 明确告知编译器，派生类中的这个函数是旨在重写基类中的虚函数；
- **好处：** 编译器会检查基类中是否存在一个同名、同参数列表、同 ⁠const 属性的虚函数。如果不存在，编译器会报错，从而避免了因拼写错误、参数不匹配等原因导致的意外函数隐藏（而不是重写）问题。

# 2 虚函数的作用

使用<font color="#4f81bd">基类指针</font>指向派生类成员并调用虚函数时，会根据成员的类型，动态的调用派生类中定义的函数。如果未定义 `virtual`，则始终调用基类函数。

注意，不是使用 `public` 派生控制时，即非 [[父类和子类]] 关系时，需要使用强制类型转换使用基类指针指向派生类：`base *ptr_base = (base *) &obj_derived;`。建议使用 `public` 派生控制。

<font color="#4f81bd">父类指针指向子类对象时，虚函数的功效才显现出来。</font>
- 编译按定义的类型（表象）来执行检查；
- 函数调用是根据<font color="#4f81bd">虚函数表</font>找入口地址，找到的是实际指向对象的函数地址（本质）。

可以通过作用域限定符 `::` 来访问虚函数，绕过运行时多态。

**虚函数 vs 函数重载：**

| 虚函数          | 函数重载          |
| ------------ | ------------- |
| 函数名、参数、返回值相同 | 函数名相同，参数不同    |
| 只能是成员函数      | 可以是成员函数和非成员函数 |
| 根据对象调用不同的虚函数 | 根据参数调用不同的重载函数 |

# 3 虚函数的工作原理

C++ 标准没有强制规定虚函数的具体实现机制，但主流编译器都采用**虚函数表 (Virtual Table, vtable)** 和 **虚指针 (Virtual Pointer, vptr)** 的机制来实现运行时多态。

# 3.1 虚函数表 vtable

每个含有虚函数的类（或其派生类）都会在编译时生成一个**虚函数表**。vtable 是一个函数指针数组，其中存储了该类所有虚函数的地址。
如果派生类重写了某个虚函数，vtable 中对应的条目就会指向派生类中的实现；否则，它会指向基类中的实现。

# 3.2 虚指针 vptr

每个含有虚函数的类的对象，都会在其实例中包含一个**虚指针**。这个 vptr 是对象的一部分，它指向该对象所属类的 vtable。

**运行时查找过程：** 当通过基类指针调用虚函数时，程序会
1. 通过基类指针找到对象的 vptr。
2. 通过 vptr 找到对象的 vtable 。
3. 在 vtable 中查找对应虚函数的地址。
4. 调用该地址处 vptr 的函数。
这个查找过程发生在运行时，因此实现了动态绑定。

# 4 虚析构函数

构造函数不能定义为虚函数，而析构函数可以定义为虚函数：派生类的析构函数可通过父类指针、引用或 `delete` 调用。

使用虚析构函数的好处：在使用 `delete` 运算符删除一个对象时，保证执行的析构函数就是该对象自己的析构函数。

**执行过程：**
如果将基类析构函数定义为虚函时，那么通过父类指针、引用析构时，首先调用派生类的析构函数，然后调用基类的析构函数，来确保所有内存空间均被释放。
