---
title: 函数模板
date created: 星期一, 十月 20日 2025, 11:33:18 中午
date modified: 星期二, 十一月 4日 2025, 2:37:30 下午
---

# 1 函数模版的定义

```C++
template <class T1, typename T2, ...>
returnType functionName (T1 a, T2 b, ...)
{
	\\ ...
}
```
`<模板形参表>` 中包含一个或多个用逗号分开的参数项，每一参数至少应在类的说明中出现一次；
模版的形式参数类型可以使用 `class` 或 `typename`（在大多数情况下，两者完全等价，可以互换使用，`typename` 更明确地表示这是一个类型参数）以及编译时常量（整型、枚举、指针或引用类型），甚至以模版为参数。

**例如**
```C++
// 模版
template <class T>
T add(T a, Tb) {
	T x;
	x = a + b;
	return x;
}

// 调用时
int x, y, z;
x = add(y, z);

double x, y, z;
x = add(y, z);

MAT x, y, z;
x = add(y, z);
```

# 2 模版函数的调用

```C++
template int add<int>(int, int); // 强制显式实例化（强制编译器编译该类型的模版函数）

z = add(x, y); // 隐式自动（编译器检测到该调用自动隐式编译该类型的模版函数）
z = add<int>(x, y); // 强制调用指定类型的函数
```
- 模板实例函数和函数模板的作用域相同；
- 在调用函数时可隐式自动生成模板实例函数；
- 调用时可以指定参数类型，实参按参数类型进行转换。
- 可强制显式生成模板实例函数（不调用也生成实例函数）；

# 3 任意个类型形参的函数模板

```C++
int println() {  
	cout << endl; return 0;  
} // 手动定义无参的函数
template < class H,class ...T> // 用…表示任意个类型形参 // 使用模版自动定义 
int println(H h, T ...t) { //递归下降展开函数的参数表  
	cout << h << " * ";  
	return 1 + println(t...); //递归下降调用  
}  
int main() { println(1, ‘2’, 3.3, “expand”); }
//输出 1 * 2 * 3.3 * expand *
```

# 4 特化实例函数

```C++
template <typename T> T max(T a, T b) {  
	return a>b?a:b;  
}  
template < > //此行可省，特化实例函数  
const char *max(const char *x, const char *y) {  
	return strcmp(x, y)>0?x:y;  
}  
```
**特化实例函数**允许手动定义某个类型的函数，会被优先调用，可用于隐藏模板实例函数。

1. 优先使用实参与形参完全匹配的特化函数；
2. 其次使用实参与形参能够匹配的模板实例函数；
3. 明确了实参类型时，对调用实参进行强制类型转换。

# 5 函数模版的特点

- 函数模板只是一种说明，并不是一个具体函数；
- 编译系统对函数模板不产生任何执行代码；
- 在遇到具体函数调用的时候，根据调用处的具体参数类型，在参数实例化以后才产生相应的代码，此代码称为模板函数。
