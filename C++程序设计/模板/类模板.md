---
title: 类模板
date created: 星期一, 十月 20日 2025, 11:33:36 中午
date modified: 星期一, 十月 20日 2025, 11:15:04 晚上
---
# 1 类模版的定义
类模板是<font color="#4f81bd">参数化的类</font>，即用于实现数据类型参数化的类。

应用类模板可以使类中的数据成员、函数成员的参数及函数成员的返回值能根据模板参数匹配情况取任意数据类型。

```C++
template <模板形参表> 
class ClassName {
    //...
};
```
`<模板形参表>` 与[[函数模板]]相同语法相同。
可以使用却缺省的类型参数`template <class T = int>`

**举例**
```C++
template <class T>  
class VECTOR { 
private: 
    T *data; 
    int size;  
public:  
    VECTOR(int); 
    ~VECTOR();  
    T & operator[](int);  
    VECTOR & operator=(const VECTOR & a);
};

// 在类体外实现函数的语法
template <class T> VECTOR<T>::VECTOR(int n) // 构造函数  
{ data = new T[size=n]; }  

template<class T> VECTOR<T>::~VECTOR( ) // 析构函数 
{ delete []data; }  

template<class T> T & VECTOR<T>::operator[ ](int i)  
{ return data[i]; }  

template <class T> VECTOR<T> & VECTOR<T>:: operator=(const VECTOR & a)  
{ ... }
```

# 2 类模版的使用
```C++
void main() { 
VECTOR<int> LI(20);
VECTOR<double> LD(30);
LI[0] = 10;
LI[1] = 20;
int z=LI[0] + LI[1];
cout << z << endl; // 显示30
}
```

# 3 类模版的特点
- 类模板自身并不产生代码； 
- 它指定类的一个家族；
- 当引用时，才产生代码，生成模板类。

# 4 类模版与[[继承]]
- 类模板可以从类模板派生
- 非模板类可以从模板类派生
- 类模板可以从非模板类派生

# 4.1 从类模板派生类模版
```C++
template <class T>
class VECTOR {
    \\...
}

template <class T>
class STACK : public VECTOR<T> {
private:
    int top;
public:
    int full() { return top==getsize();}
    int empty() {return top==0;}
    int push(T t);
    int pop(T &t);
    STACK(int s):VECTOR<T>(s) { top=0;}
    ~STACK() { }
};

template <class T>
int STACK<T>::push(T t) {
    if (full()) return 0;
    (*this)[top++]=t;
    return 1;
}
```

## 4.2 从模板类派生非模板类
```C++
class derive:public base<int> {  
    \\... 
};
```
在派生中，作为非模板类的基类，必须是类模板实例化后的模板类。

## 4.3 从非模板类派生模板类
```C++
template <class T>
class derive:public base {  
    \\... 
};
```
- 类模板可以像普通类一样从非模板类继承；
- 可以重写基类的虚函数；
- 派生类模板的构造函数需要正确调用基类构造函数；
- 支持多继承，可以从多个非模板类派生；
- 可以实现非模板的抽象基类（<font color="#4f81bd">接口</font>）。