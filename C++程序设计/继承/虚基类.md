---
title: 虚基类
date created: 星期三, 十月 22日 2025, 9:26:20 上午
date modified: 星期三, 十月 22日 2025, 2:42:53 下午
tags:
  - 课程/CPP程序设计
---

# 1 虚基类的定义

关键字为 `virtual`，把多个<font color="#4f81bd">逻辑对象</font>映射成同一个<font color="#4f81bd">物理对象</font>，共享同一个存储空间。
虚基类尽可能早地构造、尽可能晚地析构，都只进行一次。

**特性：**
- 虚基类与基类同名时，它们<font color="#4f81bd">分别拥有各自的存储空间</font>，会导致二义性访问；
- 只有<font color="#c0504d">同一棵派生树</font>的<font color="#c0504d">同名虚基类</font>才共享存储空间，参考 [[多继承#^3e396a|声明对象作为成员时的派生树生成规则]]；

**建议：** 将基类说明为对象成员，或将基类都说明为虚基类。可用作用域运算符限定要访问的成员。

在虚继承中，<font color="#c0504d">最派生类</font>负责直接初始化虚基类。
```C++
struct A { 
	int a;
	A(int a) { this->a = a; cout << "a= "<<a<<endl; }
};

struct B :virtual public A { 
	int b;
	B(int b):A(3) { // A(3) 并不会调用
		B::b = b; cout <<"b = "<<b<<endl; 
	}
};

struct C :virtual public A { 
	int c;
	C(int c):A(5) { // A(5) 也并不会调用
		C::c = c; cout << " c = "<<c<<endl; 
	}
};

struct D : public B, public C { 
	int d;
	D(int b,int c,int d):C(c),B(b),A(111) { // 关键：负责直接初始化虚基类
		D::d = d; cout << " d = "<<d<<endl; 
	} 
};
```
该派生类的派生树如下：
![[继承-5.png|350]]

# 2 派生类成员

当派生类有多个基类或虚基类时，基类或虚基类的成员之间可能<font color="#4f81bd">出现同名</font>；派生类和基类或虚基类的成员之间也可能出现同名。
- 出现上述同名问题时，必须通过面向对象的作用域解析，或者用基类名加作用域运算符 `::` 指定要访问的成员，否则就会引起二义性问题。
- 当派生类成员和基类成员同名时，<font color="#4f81bd">优先访问作用域小的成员</font>，即优先访问派生类的成员。
- 当派生类数据成员和派生类函数成员的参数同名时，在函数成员内优先访问函数参数。

# 3 单重及多重继承的构造与析构

析构和构造的顺序相反，派生类对象的构造顺序：
1. 按后根遍历的顺序，构造倒派生树中所有<font color="#4f81bd">虚基类</font>；
2. 按定义顺序构造派生类的所有<font color="#4f81bd">直接基类</font>；
3. 按定义顺序构造 (初始化) 派生类的<font color="#4f81bd">所有数据成员</font>，包括对象成员、`const` 成员和引用成员；
4. 执行派生类<font color="#4f81bd">自身的构造函数体</font>。
如果构造中虚基类、基类、对象成员、`const` 及引用成员又是派生类对象，则派生类对象重复上述构造过程（但同名虚基类对象在同一棵派生树中仅构造一次）。
