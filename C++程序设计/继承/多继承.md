---
title: 多继承
date created: 星期三, 十月 22日 2025, 8:50:56 早上
date modified: 星期三, 十月 22日 2025, 2:51:41 下午
tags:
  - 课程/CPP程序设计
---

# 1 多继承

如右图所示，即为多继承。

![[继承-1.png]]

```C++
Class ClassName : <派生控制> Base1,
		    	  //...
				  <派生控制> Basen
{
//...
};
```

同一个类不能多次作为某个派生类的直接基类，可以多次作为一个类的间接基类（比如包含一个该类的成员对象，或链式继承）。

# 2 构造函数、派生类对象的构造和析构顺序

**构造顺序**：
```C++
struct A { 
	int a;
	A(int a) { 
		this->a = a; 
		cout << "a= "<<a<<endl; 
	}
};

struct B : public A { 
	int b;
	B(int b) : A(3) {
		B::b = b; 
		cout <<"b = "<<b<<endl; 
	}
};

struct C : public A { 
	int c;
	C(int c) : A(5) {
		C::c = c; 
		cout <<"c = "<<c<<endl; 
	}
};

struct D : public B, public C { 
	int d;
	D(int b,int c,int d) : C(c), B(b) {
		D::d = d; 
		cout <<"d = "<<d<<endl; 
	}

};
```
![[继承-2.png|350]]

1. 建立一棵派生树。其结点的顺序为：按定义派生类时基类出现的顺序，从左到右。若类中<font color="#4f81bd">声明了对象作为成员</font>，则以该对象为<font color="#4f81bd">根</font>再<font color="#4f81bd">构造另一颗派生树</font>。 ^3e396a
2. 对象构造时的顺序为：按树的<font color="#4f81bd">后序遍历</font>访问结点的原则，确定构造顺序。

若将 `struct D` 的定义改为：
```C++
struct D : public B { 
	C objc;
	int d;
};
```
其内存空间则变为：
![[继承-3.png|350]]


**析构顺序：** 与构造顺序相反。

# 3 多继承带来的问题

如图所示的继承方式带来了一些问题：
![[继承-4.png|350]]
- 当对象成员和基类<font color="#4f81bd">存在共同的基类</font>时，就可能对同一个物理对象<font color="#4f81bd">重复初始化</font>（可能是危险的和不必要的）；
- 多继承不能解决同一个物理对象初始化多次的问题；
- 可以采用全局变量、静态数据成员，解决同一个物理对象初始化两次的问题，但解决相关析构问题复杂。

我们希望类 D 只拥有一个类 A，于是，引入了 [[虚基类]] 实现了两个对象共享一个物理对象的需求。

# 4 多继承类的内存布局

多继承派生类包含各个基类的存储空间。
1. 如果存在虚基类和同名基类，[[虚基类]] 和同名基类的存储空间是相互独立的。
2. 如果派生类存在同名的虚基类，同一棵派生树的所有虚基类共享存储空间，虚基类通过偏移指向共享存储空间，该存储空间出现在所有直接基类之后。
3. 如果基类或派生类存在虚函数，则在派生类存储空间中，包含一个单元存放虚函数入口地址表首地址。
4. 派生类的存储空间不包括基类、虚基类和对象成员的静态数据成员。

派生类有 [[虚基类]] 的情况下的详解：
虚基类的存储空间建于派生类的尾部，且按虚基类的构造顺序建立。
1. 派生类依次处理每个直接基类或虚基类，如果为直接基类，则为其建立存储空间，如果为直接虚基类则建立一个到虚基类的偏移。
2. 如果派生类继承的第一个类为非虚基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。对于其他任何情形，派生类在处理完所有基类或虚基类后，根据派生类是否新定义了虚函数，确定是否为该表首址分配存储单元。
