---
tags:
  - "#课程/CPP程序设计"
title: 继承
date created: 星期六, 十月 18日 2025, 4:27:22 下午
date modified: 星期五, 十月 24日 2025, 9:26:25 上午
---

# 单继承类  

**定义格式：**
```C++
<class/struct> <派生类名>: <派生控制符 private/protected/public> <基类名> {
	<派生类新定义成员> 
	<派生类重定义基类同名的数据和函数成员> 
	<派生类声明恢复基类成员访问权限> 
};
```
派生控制符可以缺省，`class` 默认为 `private`，`struct` 默认为 `public`。
不能用 `union` 作为基类或派生类。

# 继承方式

类定义中： 
- public 成员: 可被任何类访问，公开的 ；
- protected 成员: 可被本类及其派生类访问；
- private 成员: 只限于本类访问 。

派生控制：指明基类的成员在派生类的访问方式。
派生控制符 `private`、 `protected` 、`public` 都无法访问基类的私有成员。仅控制派生类成员权限。
- `public`：保持基类成员权限不变；
- `protected`：继承自基类的 `protected` 、`public` 成员都变为 `protected`；
- `private`：继承自基类的 `protected` 、`public` 成员都变为 `private`。

|  继承类型 | 基类成员特性 | 派生类成员特性  |
| ----: | :----: | :------: |
|     ┌ | 公有     |    公有    |
| 公有继承├ | 保护     |    保护    |
|     └ | 私有<br> |   不可访问   |
|     ┌ | 公有<br> |  保护<br>  |
| 保护继承├ | 保护<br> |  保护<br>  |
|     └ | 私有<br> | 不可访问<br> |
|     ┌ | 公有<br> |  私有<br>  |
| 私有继承├ | 保护<br> |  私有<br>  |
|     └ | 私有<br> | 不可访问<br> |

# 成员访问

可以通过派生类声明恢复或修改基类成员访问权限。
```C++
<public/protected/private>:
	using(可选) <类名>::<成员>
```

同名成员优先级：标识符作用范围越小，优先级越高。要使用范围更大的标识符，使用 `类名：：` 限定。
范围从小到大：
```C++
作用于函数成员内（局部变量）-> 作用于类或派生类内 -> 作用于基类内 -> 作用于虚基类内
```

```C++
A *p = &b;
Z = p->getx(); // 若 A 和 B 类都有 getx()，访问的是 A 类中的
```

派生类中访问基类函数，函数名前不需要加对象或对象指针。

# 构造和析构

派生类不能继承基类的构造函数、析构函数，拥有自己的构造函数、析构函数。

构造函数格式：
```C++
派生类名(参数表1):基类名(参数表2),其余派生类成员的构造 {
	函数体;
}; // 若无基类名的构造，则执行基类中无参构造函数
```

定义派生类的移动构造函数时，参数表应该显示调用基类的移动构造函数，确保使用移动构造。

```C++
class B : public A {
public:
    std::vector<int> data;
    
    B(B&& other) noexcept // B 的移动构造函数
        : A(std::move(other)), // !!! 关键：显式调用 A 的移动构造函数
          data(std::move(other.data)) // 移动 B 自己的成员
    { std::cout << "B Move Ctor" << std::endl; }
    
    B(const B& other) // B 的拷贝构造函数
        : A(other), // 调用 A 的拷贝构造函数
          data(other.data) // 拷贝 B 自己的成员
    { std::cout << "B Copy Ctor" << std::endl; }

    // ... 其他构造函数和析构函数 ...
};
```

单继承派生类只有一个（虚）基类，构造顺序优先级：
1. 调用派生类的虚基类的构造函数；（一定会执行）
2. 调用派生类的基类的构造函数；（一定会执行）
3. 按照派生类数据成员<font color="#4f81bd">声明顺序</font>初始化数据成员或调用构造函数，对象成员无论列出与否总会被构造；
4. 最后执行派生类的构造函数体。

关于 [[Study/C++程序设计/虚基类]]
```C++
class D : virtual <派生控制> baseC; // baseC 为虚基类
```

若构造函数的参数都有缺省值，则可以当成无参的构造函数。

若派生类中没有定义构造函数，则自动使用基类中的无参构造函数。

# 父类和子类

如果<font color="#4f81bd">派生控制</font>为 `public` ，派生类称为基类的子类，基类称为派生类的父类。

以下操作无须通过强制类型转换，编译时按父类说明的权限访问成员：
- <font color="#4f81bd">父类指针</font>可以直接指向子类对象；
- <font color="#4f81bd">父类引用</font>可以直接引用子类对象；

非父子类可以通过强制类型转换实现相同功能。

```C++
class POINT{
	int x, y;
public:
	int getx( ){ return x; } 
	int gety( ){ return y; }
	void show( ){ cout<<"Show a point\n"; }
	POINT(int x,int y): x(x), y(y){ }
};

class CIRCLE: public POINT{ //公有继承，构成父子关系
	int r;
public: 
	int getr( ){ return r; }
	void show( ){ cout<<"Show a circle\n"; }
	CIRCLE(int x, int y, int r):POINT(x,y){ 
		CIRCLE::r = r; 
	}
} c(3,7,8);

void main(void) {
	POINT *p = &c; 
	//父类指针 p 指向子类对象，不用类型转换
	p=(POINT*)&c;
	cout<<c.getr( )<<p->getx( ); 
	//不能用p->getr()
	//编译时无POINT::getr( )
	p->show( ); 
	//p指向子类对象，但调用的是POINT::show( )
}
```

在派生类成员/[[友元]] 函数内部（不论父子关系）：
- 基类指针可以直接指向该派生类对象；
- 基类被等同地当作派生类的父类。

基类指针指向或引用派生类对象的作用：在父类有 [[虚函数]] 时，对 [[虚函数]] 的访问。
- 通过父类指针调用虚函数时进行晚期绑定；
- 根据对象的实际类型绑定到合适的成员函数；
- 父类指针实际指向的对象的类型不同；
- 虚函数绑定的函数的行为不同，从而产生多态。

# 派生类的内存布局

1. 派生类对象的储存空间包含基类的数据成员；
2. 计算派生类对象存储空间时，基类和派生类的 [[类的静态成员|静态数据成员]] 不应计算在内。

# 禁止派生

禁止一个类产生派生类的关键字：`final`
```C++
class A final {
	······
};
```

`final` 还能禁止 [[虚函数]] 被重写：
```C++
virtual <返回类型> fun(参数列表) final;
```
