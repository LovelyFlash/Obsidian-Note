---
title: 引用变量
date created: 星期三, 十月 22日 2025, 9:55:35 晚上
date modified: 星期三, 十月 22日 2025, 11:40:56 晚上
---
**引用**是 C++ 中一个非常重要的概念，它为已存在的对象提供了一个**别名**。引用本身不是一个对象，它只是一个已经存在的对象的另一个名称。

# 1 引用的声明与初始化

**语法：** 
```C++
Type& ref_name = variable;
```

**核心规则：**
1. **必须在声明时初始化：** 引用一旦声明，就必须立即绑定到一个对象。
2. **不能为** ⁠`null` **：** 引用必须始终引用一个有效的对象。
3. **一旦初始化不能改变指向：** 引用一旦绑定到一个对象，就不能再重新绑定到另一个对象。它将终生作为该对象的别名。

**示例：**
```C++
int value = 10;
int& ref_value = value; // 声明一个 int 类型的左值引用 ref_value，并将其绑定到 value

std::cout << "value: " << value << std::endl;     // 输出: 10
std::cout << "ref_value: " << ref_value << std::endl; // 输出: 10

ref_value = 20; // 通过引用修改值，实际上修改的是 value
std::cout << "value after modification: " << value << std::endl; // 输出: 20

// int& another_ref; // 错误：引用必须初始化
// int& invalid_ref = nullptr; // 错误：引用不能为 null
// int other_value = 30;
// ref_value = other_value; // 错误：这不是重新绑定，而是将 other_value 的值赋给 ref_value (即 value)
```
  

# 2 引用的关键特性

**别名：** 引用是其所绑定对象的另一个名称。使用引用变量，等同使用被引用的变量。对引用变量取地址，等同对被引用的变量取地址。

**没有自己的存储空间（概念上）：** 编译器通常会将引用优化为直接访问其所绑定的对象，因此引用本身通常不占用独立的内存空间（尽管在某些实现中，编译器可能会在内部将其实现为指针，但从语言层面看，它没有独立的地址）。

**多重引用：** 对引用变量的再引用 要追溯到最原始的被引对象（不同于二级指针）。

**安全性：** 由于引用不能为 ⁠`null` 且不能重新绑定，它比指针更安全，避免了空指针和野指针的问题。

**对指针变量的引用：** 引用指针变量时，引用的是指针变量本身，而不会引用到指针指向的地址。
```C++
int * x = (int *)malloc(sizeof(int));
int * &y = x;
```

**语法简洁：** 使用引用时无需解引用操作符 `*`，语法更简洁直观。

# 3 引用的类型

C++11 引入了两种主要的引用类型：

## 3.1 左值引用

**语法：** `⁠Type&`
**绑定对象：** 只能绑定到**左值**（可以取地址、有名称、可以出现在赋值运算符左侧的表达式）。

⁠`const` **左值引用：** `const Type&`
这是一个特例，它可以绑定到**左值**，也可以绑定到**右值**（临时的、没有名称、不能取地址的表达式）。当绑定到右值时，⁠const 左值引用会**延长右值的生命周期**，使其在引用的作用域内保持有效。
**示例：** ⁠`const int& ref_to_temp = 10;` 合法，⁠10 是右值。

## 3.2 右值引用（C++11）

**语法：** ⁠`Type&&`
**绑定对象：** 只能绑定到**右值**。
**主要用途：** 实现**移动语义** 和 **完美转发**，以提高程序性能。
**示例：**` ⁠int&& ref_to_rvalue = some_function_returning_int();`

# 4 引用的主要用途

## 4.1 函数参数传递

`void func(Type& param);`
通过引用传递参数，函数内部可以修改原变量，同时避免了对象拷贝的开销。

`void func(const Type& param);`
通过 ⁠`const` 引用传递参数，函数内部不能修改原变量，但同样避免了对象拷贝的开销，是传递大型对象的首选方式。

## 4.2 函数返回值

`Type& func();`
函数返回一个引用，允许调用者修改原变量。

`const Type& func();`
函数返回一个 ⁠const 引用，调用者不能修改原变量。

许多运算符（如 `⁠operator[]`、`⁠operator=`）的重载函数会返回引用，以支持链式操作或允许修改。

**注意：** 必须返回对一个**生命周期超出函数调用**的对象（如全局变量、静态变量、堆上分配的对象）的引用，否则会导致返回悬空引用。

# 4.3 迭代器

STL 容器的迭代器通常通过解引用操作符 `*` 返回对元素的引用。

# 5 引用与指针的区别

|   |   |   |
|---|---|---|
|特性|引用 (Reference)|指针 (Pointer)|
|**初始化**|必须在声明时初始化，且不能为 ⁠null。|可以不初始化（为 ⁠nullptr），可以指向 ⁠null。|
|**重新绑定**|一旦绑定，不能改变指向。|可以随时改变指向，指向不同的对象。|
|**解引用**|直接使用引用名即可，无需解引用操作符。|需要使用 ⁠* 解引用操作符来访问所指向的值。|
|**内存**|概念上不占用独立内存（是别名）。|占用独立内存空间，存储地址。|
|**算术运算**|不能进行算术运算（如 ⁠ref++ 只是操作原变量）。|可以进行算术运算（如 ⁠ptr++ 移动到下一个地址）。|
|**安全性**|更安全，避免空引用和野引用。|存在空指针和野指针的风险。|

# 6 优点

- **语法简洁：** 比指针更简洁直观，无需解引用操作符。
- **安全性高：** 避免了空指针和野指针的风险。
- **效率高：** 作为函数参数传递时，避免了对象拷贝的开销，尤其对于大型对象。
