---
title: 函数指针
date created: 星期三, 十月 22日 2025, 11:45:46 晚上
date modified: 星期四, 十月 23日 2025, 12:00:39 凌晨
---
函数指针是一种特殊的指针，它存储的不是变量的地址，而是**函数的内存地址**。通过函数指针，我们可以像操作变量一样操作函数，例如将函数作为参数传递给其他函数，或者将函数存储在数据结构中。

# 1 函数指针的声明

函数指针的声明语法与普通指针类似，但需要指明它所指向的函数的**返回类型**和**参数列表**。

**语法：** ⁠`ReturnType (*pointer_name)(ParameterType1, ParameterType2, …);`

**关键点：** ⁠`(*pointer_name)` 必须用括号括起来，以表明 ⁠`pointer_name` 是一个指针，而不是一个返回指针的函数。

**示例：**
```C++
// 假设有以下函数
int add(int a, int b) {
    return a + b;
}

void greet(const char* name) {
    std::cout << "Hello, " << name << "!" << std::endl;
}

// 声明一个函数指针，指向返回 int，接受两个 int 参数的函数
int (*add_ptr)(int, int);
// 声明一个函数指针，指向返回 void，接受一个 const char* 参数的函数
void (*greet_ptr)(const char*);
```

# 2 函数指针的初始化与赋值

将函数的地址赋给函数指针。`&` 运算符是可选的，因为函数名本身在表达式中就会被隐式转换为其地址。

**示例：**
```C++
// 初始化
int (*add_ptr)(int, int) = &add; // 显式取地址
// 或者
int (*add_ptr_alt)(int, int) = add; // 隐式转换为地址

// 赋值
greet_ptr = &greet; // 显式取地址
// 或者
greet_ptr = greet; // 隐式转换为地址
```

# 3. 通过函数指针调用函数

通过函数指针调用函数有两种方式：显式解引用和隐式解引用。

- **显式解引用：** `⁠(*pointer_name)(arguments);`
- **隐式解引用：** `⁠pointer_name(arguments);` 更常用，更简洁。

**示例：**
```C++
int result = (*add_ptr)(5, 3); // 显式解引用调用
std::cout << “Result of add: ” << result << std::endl; // 输出: 8

greet_ptr(“Alice”); // 隐式解引用调用
// 或者
(*greet_ptr)(“Bob”); // 显式解引用调用
```

# 4 函数指针的常见用途

函数指针在 C++ 中有多种应用场景，尤其是在需要**回调机制**或**运行时选择行为**时。

# 4.1 回调函数

将一个函数指针作为参数传递给另一个函数，让被调用的函数在特定时机执行这个传入的函数。

**示例：排序算法中的比较函数**
```C++
// 比较函数类型定义
typedef bool (*CompareFunc)(int, int);

// 冒泡排序函数，接受一个比较函数指针
void bubbleSort(int arr[], int n, CompareFunc compare) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (compare(arr[j], arr[j+1])) { // 使用传入的比较函数
                std::swap(arr[j], arr[j+1]);
            }
        }
    }
}

// 升序比较函数
bool compareAsc(int a, int b) {
    return a > b; // 如果 a > b，则交换 (升序)
}

// 降序比较函数
bool compareDesc(int a, int b) {
    return a < b; // 如果 a < b，则交换 (降序)
}

int main() {
    int arr1[] = {5, 2, 8, 1, 9};
    int arr2[] = {5, 2, 8, 1, 9};
 	int n = sizeof(arr1) / sizeof(arr1[0]);

    bubbleSort(arr1, n, compareAsc); // 升序排序
    std::cout << “Ascending: “;
    for (int i = 0; i < n; ++i) std::cout << arr1[i] << ” “; // 1 2 5 8 9

    bubbleSort(arr2, n, compareDesc); // 降序排序
    std::cout << “\nDescending: “;
    for (int i = 0; i < n; ++i) std::cout << arr2[i] << ” “; // 9 8 5 2 1

    return 0;
}
  ```
  

# 4.2 状态机

将不同状态对应的处理函数存储在函数指针数组中，根据当前状态调用相应的函数。

**示例：**
```C++
enum State { STATE_A, STATE_B, STATE_C };

void handleStateA() { std::cout << “Handling State A” << std::endl; }

void handleStateB() { std::cout << “Handling State B” << std::endl; }

void handleStateC() { std::cout << “Handling State C” << std::endl; }

// 函数指针数组
void (*stateHandlers[])() = { handleStateA, handleStateB, handleStateC };

int main() {
    State current_state = STATE_A;
    stateHandlers[current_state](); // 调用 handleStateA
    current_state = STATE_B;
    stateHandlers[current_state](); // 调用 handleStateB
    return 0;
}
  ```

# 5 函数指针的局限性与现代 C++ 替代方案

尽管函数指针非常强大，但它们也有一些局限性：
- **语法复杂：** 声明和使用语法相对复杂，容易出错。
- **类型安全：** 必须严格匹配函数的签名，否则会导致编译错误。
- **无法捕获上下文：** 函数指针只能指向全局函数或静态成员函数，无法直接捕获其所在作用域的局部变量。

现代 C++ 提供了更灵活、更安全的替代方案：
- ⁠`std::function` **(C++11)：** 一个通用的函数包装器，可以存储任何可调用对象（函数指针、函数对象、Lambda 表达式、成员函数指针）。它提供了更好的类型安全性和灵活性。
- **Lambda 表达式 (C++11)：** 匿名函数，可以直接在代码中定义，并且可以捕获其所在作用域的变量，非常适合作为回调函数。
- **成员函数指针：** 专门用于指向类的非静态成员函数，语法更复杂，需要通过对象实例来调用。
