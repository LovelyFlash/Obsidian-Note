---
title: 函数
date created: 星期四, 十月 23日 2025, 12:00:45 凌晨
date modified: 星期四, 十月 23日 2025, 8:54:23 晚上
---

# 1 函数的说明和定义

**全局函数：**
可被任何程序文件的程序调用，只有全局 `main` 函数不可被调用。

**内联函数：** `inline`
作用为优化编译器编译函数的方式。将函数片段直接插入到调用处，而不是调用函数，降低了开销。使用场景有
- **性能优化：** 某些处理器（如支持 SIMD 指令的处理器）在访问特定对齐的数据时效率更高。
- **硬件接口：** 与硬件设备交互时，可能需要数据满足特定的对齐要求。
- **跨平台兼容性：** 确保数据结构在不同系统上具有相同的内存布局。

**静态函数：**`static`
- 当在类中声明静态函数时，参考 [[类的静态成员#3 静态函数成员|静态函数成员]]
- 当在类外声明静态函数时，该函数为文件作用域。

**常量表达式函数：** `constexpr`
参考 [[修饰符#8 ⁠`constexpr` (C++11)| constexpr 修饰符]]
- 用 `constexpr` 定义的函数当其实参为常量时，可以被更彻底的优化；
- `constexpr` 函数内不能有**goto**语句或标号，也不能有 `try` 语句块；
- `constexpr` 函数不能调用非 `constexpr` 的函数，如 `printf` 函数；
- `constexpr` 函数不能定义 `static` 变量、线程本地变量等永久期限变量；
- 类似 `inline` 函数，`constexpr` 函数的函数体可能被优化掉，其作用域相当于 `static`；
- 函数 `main` 为全局作用域，故不能定义为 `constexpr` 函数。

# 2 函数的参数

# 2.1 可变参数函数

在 C++ 中，函数可以接受可变数量的参数，这在某些需要灵活参数列表的场景中非常有用（例如 ⁠printf 函数）。实现可变参数函数有两种主要方式：C 风格的可变参数宏和现代 C++ 的可变参数模板。

# 2.1.1 C 风格的可变参数函数

C 风格的可变参数函数使用省略号 ⁠`…` 来表示参数列表的其余部分是可变的。

- **语法：** ⁠`ReturnType functionName(FixedArg1, FixedArg2, …);`
- **特点：** 至少需要一个固定参数，以便函数能够知道如何处理后续的可变参数。

为了安全且可移植地处理 C 风格的可变参数，C++ 继承了 C 语言的 \<cstdarg\>（或 ⁠\<stdarg.h\>) 头文件中定义的宏。

- `va_list`：一个类型，用于存储可变参数列表的信息。
- ⁠`va_start`：初始化 ⁠`va_list` 对象。
- ⁠`va_arg`：从 ⁠`va_list` 中获取下一个参数。
- ⁠`va_end`：清理 ⁠`va_list` 对象。

**示例：**
  ```C++
#include <cstdarg> // 包含 C 风格可变参数宏的头文件
#include <iostream>

// 正确的 C 风格可变参数函数
int sum_safe(int count, …) { // count 是固定参数，用于指示后续可变参数的数量
    int s = 0;
    va_list args; // 声明一个 va_list 对象
    va_start(args, count); // 初始化 args，第二个参数是最后一个固定参数

    for (int k = 0; k < count; k++) {
        // va_arg 从 args 中获取下一个参数，并指定其类型为 int
        s += va_arg(args, int);
    }

    va_end(args); // 清理 args
    return s;
}

// 示例调用
int main() {
    std::cout << "Sum of 3 numbers: " << sum_safe(3, 10, 20, 30) << std::endl; // 输出 60
    std::cout << "Sum of 5 numbers: " << sum_safe(5, 1, 2, 3, 4, 5) << std::endl; // 输出 15
    // 警告：如果 count 与实际传入的参数数量或类型不匹配，仍然可能导致未定义行为。
    // 例如 sum_safe(3, 10, 20); // 传入参数不足
    // 例如 sum_safe(3, 10, 20, "hello"); // 传入类型不匹配
    return 0;
}
```

  

# 2.1.2 现代 C++ 的可变参数函数

C 风格的可变参数函数虽然灵活，但存在类型不安全、难以使用等缺点。现代 C++ (C++11 及更高版本) 提供了更安全、更强大、更类型安全的替代方案：

# 2.1.2.1 可变参数模板

- **语法：** `⁠template<typename… Args> void func(Args… args);`
- **特点：** 可以在编译时处理任意数量和任意类型的参数，具有完全的类型安全性。
- **用途：** 实现 ⁠`std::tuple`、⁠`std::make_unique` 等泛型功能。

```C++
template<typename T>
T sum_modern(T t) {
    return t;
}

template<typename T, typename… Args>
T sum_modern(T first, Args… rest) {
    return first + sum_modern(rest…);
}

// 示例调用
int main() {
    std::cout << "Sum: " << sum_modern(1, 2, 3, 4, 5) << std::endl; // 输出 15
    std::cout << "Sum: " << sum_modern(1.1, 2.2, 3.3) << std::endl; // 输出 6.6
    return 0;
}
  ```

# 2.1.2.2 `std::initializer_list` (C++11)

- **语法：** `⁠ReturnType functionName(std::initializer_list<Type> list);`
- **特点：** 用于接受同类型参数的可变数量列表。
- **用途：** 构造函数、函数参数，例如 ⁠`std::vector` 的构造函数。

```C++
#include <initializer_list>

double sum_list(std::initializer_list<double> list) {
    double total = 0;
    for (double val : list) {
        total += val;
    }
    return total;
}

// 示例调用
int main() {
    std::cout << "Sum: " << sum_list({1.0, 2.0, 3.0, 4.0}) << std::endl; // 输出 10.0
    return 0;
}
```
  

# 2.1.2.3**函数重载

对于参数数量较少且固定的几种情况，可以直接通过重载函数来提供不同的版本。

# 2.2 缺省参数

可以在定义函数时为参数提供默认值。
**语法：** `retuenType funcName(type arg1, type arg2, type arg3 = value3)`
**注意：** 如果某个参数给了缺省值，其右边的参数都需要给参数值。
