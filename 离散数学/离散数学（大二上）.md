# 第一章 数论初步及应用##

## 1.1 除法和模运算

### 1.1.1 整除

**定义**：$如果 a 和 b 是整数，且 𝑎≠0，那么如果存在一个整数 c，使得 b=ac，则称 a 整除 b.$
- 当 $a$ 整除 $b$ 时，我们称 $a$ 是 $b$ 的因数或除数，并且称 $b$ 是 $a$ 的倍数
- 符号 $a | b$ 表示 $a$ 整除 $b$
- 如果 $a ∣ b$，那么 𝑏/a 是一个整数
- 如果 𝑎 不整除 𝑏，我们记作 $𝑎 ∤ 𝑏$
**良序原理（ Well Ordering Principle）**：$每个非空的自然数集都有最小的元素$

### 1.1.2 同余关系

**定义**：$如果 𝑎 和 𝑏 是整数，且 𝑚 是正整数，那么当 𝑚 整除 𝑎−𝑏 时，称 𝑎 与 𝑏 在模 𝑚 下同余，记作 𝑎 ≡ 𝑏 (mod 𝑚).$

- 符号 𝑎 ≡ 𝑏 (mod 𝑚) 表示 𝑎 与 𝑏 在模 𝑚 下同余.
- 我们称 𝑎 ≡ 𝑏 (mod 𝑚) 为一个同余关系，且 𝑚 是其模数.
- 两个整数在模 𝑚 意义下同余当且仅当它们除以 𝑚 后的余数相同.
- 如果 𝑎 不与 𝑏 在模 𝑚 意义下同余，我们记作 $𝑎 ≢ 𝑏(mod\ 𝑚)$.

同余关系有：自反性，对成型，传递性。

在 $𝑎≡𝑏 (mod\ 𝑚)$ 和 $𝑎\ mod\ 𝑚=𝑏$ 中，mod 的用法是不同的

- $a≡b (mod\ m)$ 是整数集上的一个关系，表示 𝑎 和 𝑏 在模 𝑚 意义下同余（类似于 " 等号 "）.
- 在 $𝑎\ mod\ 𝑚=𝑏$ 中，"mod" 表示一个函数，该函数返回 𝑎 除以 𝑚 后的余数（类似于 " 除号 "）.

设 𝑚 为正整数，𝑎 和 𝑏 为整数，

则

$$
\huge
(𝑎 + 𝑏) (𝒎𝒐𝒅\ 𝑚) = ((𝑎\ 𝒎𝒐𝒅\ 𝑚) + (𝑏\ 𝒎𝒐𝒅\ 𝑚))\ 𝒎𝒐𝒅\ 𝑚 
$$

且

$$
\huge
𝑎𝑏\ 𝒎𝒐𝒅\ 𝑚 = ((𝑎\ 𝒎𝒐𝒅\ 𝑚) (𝑏\ 𝒎𝒐𝒅\ 𝑚))\ 𝒎𝒐𝒅\ 𝑚
$$

### 1.1.3 二进制模幂算法

使用 n 的二进制展开, $n = (a_{k-1},…,a_1,a_0)_2$ , 来计算 $b^n$ .

注意到: $b^n=b^{a_k-1*2^{k+1}+…+a_1*2+a_0}=(b^{2^{k-1}})^{a_k-1}…(b^2)^{a_1}b^{a_0}$

该算法依次计算 $b\ mod\ m$, $b_2\ mod\ m$, $b_4\ mod\ m$, …, 然后将 $a_j = 1$ 的项相乘.

### 1.1.4 群

群, $G$, 是一个元素集合，带有一个关联的二元运算，记作 * , 有时被表示为 $\{G, * \}$，且

G 中元素满足以下性质：

- **封闭性（Closure）**：$若𝑎 ∈ 𝐺且𝑏 ∈ 𝐺，则𝑎 \cdot 𝑏 ∈ 𝐺$
- **结合律（Associative）**：$对于𝐺中的任意元素𝑎, 𝑏和𝑐, 满足𝑎 \cdot (b \cdot c) = (𝑎 \cdot 𝑏) \cdot 𝑐$
- **单位元（Identity element）**：$存在元素 e ∈ 𝐺，使得对于𝐺中的任意元素𝑎满足 𝑎 \cdot 𝑒 = 𝑒 \cdot 𝑎 = 𝑎$
- **逆元（Inverse element）**：$对于𝐺中的任意元素𝑎，存在𝐺中的另一元素𝑎- 使得 a\cdot a'=a'\cdot a=e$

一个群若满足交换律，则被称为**交换群（或阿贝尔群， Abelian group）**:

- **交换律（Commutative）**：$对于𝐺中的任意元素𝑎和𝑏, 满足𝑎 : 𝑏 = 𝑏 : 𝑎$

一个群 G 称为**循环群（cyclic group）**，如果 $G$ 中的每一个元素都可以表示为某个固定元素 $g$ 的幂 $g^k$ ($k$ 是一个整数)。这个固定元素 $g$ 被称为**生成元（generator）**。

- 无论是有限循环群，还是无限循环群，**循环群总是交换群（abelian）**

### 1.1.5 环

环 {𝑅, +, ×}，是一个具有两个二元运算的元素集合，分别称为加法（+）和乘法（×），且满足以下条件:

- {𝑅, +}是一个交换群，其单位元写作 0，𝑎的逆元为−𝑎
- **乘法下封闭（ Closure under multiplication ）**：若𝑎 ∈ 𝑅且𝑏 ∈ 𝑅，则𝑎×𝑏 ∈ 𝑅
- **乘法结合律（ Associativity of multiplication ）**：对于𝑅中任意元素𝑎, 𝑏和𝑐, 满足 $𝑎× 𝑏×𝑐 = (𝑎×𝑏)×𝑐$
- **乘法分配律（ Distributive laws）**:
	- 对于𝑅中任意元素𝑎, 𝑏和𝑐, 满足 $𝑎× 𝑏 + 𝑐 = 𝑎×𝑏 + 𝑎×𝑐$
	- 对于𝑅中任意元素𝑎, 𝑏和𝑐, 满足 $(𝑎 + 𝑏)×𝑐 = 𝑎×𝑐 + 𝑏×𝑐$

$$
\begin{matrix}
&不要求存在乘法单位元 \\
&不要求存在乘法逆元 \\
&不要求满足乘法交换律
\end{matrix}
$$

若一个环满足乘法交换律，则称其为交换环:

- **乘法交换律（ Associativity of multiplication ）**：对于 𝑅中任意元素𝑎和𝑏, 满足 𝑎𝑏 = 𝑏𝑎
若一个环满足以下条件，则称其为整环:
- **乘法单位元（Multiplicative identity）**：存在元素𝟏 ∈ 𝑅 ，使得对于𝑅中的任意元素𝑎满足 𝑎×1 = 1×𝑎 = 𝑎
- **无零因子（ No zero divisors ）**：对于𝑅中的任意元素𝑎 和𝑏，若𝑎𝑏 = 0，则必有𝑎 = 0 或𝑏 = 0
整环示例:
整数集合 ℤ 在一般的加法和乘法下

> （1）加法下封闭性： 𝑎 + 𝑏 ∈ 𝑅
> （2）加法结合律： 𝑎 + 𝑏 + 𝑐 = 𝑎 + (𝑏 + 𝑐)
> （3）加法单位元：a + 0 = 0 + 𝑎 = 𝑎
> （4）加法逆元：−𝑎
> （5）加法交换律：𝑎 + 𝑏 = 𝑏 + 𝑎
> （6）乘法下封闭性：𝑎𝑏 ∈ 𝑅
> （7）乘法结合律：𝑎× 𝑏𝑐 = (𝑎𝑏)×𝑐
> （8）乘法分配律：𝑎× 𝑏+𝑐 = 𝑎𝑏+𝑎𝑐，(𝑎+𝑏)×𝑐 = 𝑎𝑐+𝑏𝑐
> （9）乘法交换律：𝑎𝑏 = 𝑏𝑎
> （10）乘法单位元：𝑎×1 = 1×𝑎 = 𝑎
> （11）无乘法零因子：𝑎𝑏 = 0 ⟹ (𝑎 = 0) ∨ (𝑏 = 0)

### 1.1.6 域

域 {𝐹, +, ×}是一个存在乘法逆元的整环，也即满足以下性质：

-  {𝐹, +, ×}是整环，满足性质 (1)~(11)
- 性质 (12)- 存在乘法逆元（Multiplicative inverse）: 对于𝐹中任意**非 0** 元素𝑎，存在𝐹中的另一元素 $𝑎^{-1}$ 使得 $𝑎×𝑎^{-1} = 𝑎^{-1}×𝑎=1$
- 性质 (4)- 存在加法逆元（Additive inverse）: 对于𝐹中任意元素𝑎， 存在𝐹中的另一元素−𝑎使得𝑎+(−𝑎) =(−𝑎) +𝑎=0

**除法定义**： $𝑎/𝑏 = 𝑎(𝑏^{-1})$
![[001 数论和密码学(中文)-完整.pdf#page=38&rect=96,26,629,492|001 数论和密码学(中文)-完整, p.38]]

## 1.2 素数和最大公约数

### 1.2.1 素数

**定义**：$对于一个$<font color="#c00000">大于 1</font>$的正整数 𝑝，若𝑝的正因子只有 1 和 𝑝 本身，则称𝑝为素数（prime） 。$

### 1.2.2 算术基本定理

**定理**: 每一个大于 1 的正整数都可以<font color="#c00000">唯一地</font>表示为一个素数，或者表示为两个或更多素数的乘积，其中素因数<font color="#c00000">按照大小不减</font>的顺序排列.

### 1.2.3 最大公约数

**定义**: 设 𝑎 和 𝑏 为整数，且<font color="#c00000">不全为零</font>。能够同时整除 𝑎 和 𝑏 的最大整数 𝑑 称为𝑎和𝑏的最大公约数，记作 $gcd(a, b)$.

**最大公约数表示成一个线性组合**

- **定理**: 若 𝑎 和 𝑏 是任意整数且不全为零，则 $gcd(a, b)$ 是集合{𝑎𝑥 + 𝑏𝑦 ∶ 𝑥, 𝑦 ∈ ℤ} 中的最小正整数元素
- **Bézout's Theorem (贝祖定理)**：若 𝑎 和 𝑏 是正整数， 则存在整数 𝑠 和 𝑡 使得 $gcd(a, b) = sa + tb$.
- **定义**: 若 𝑎 和 𝑏 是正整数，则使得 $gcd(a, b) = sa + tb$ 的整数 𝑠 和 𝑡 称为 𝑎 和 𝑏 的贝祖系数.

#### 1.2.3.1 用素因子分解法找最大公约数

假设 𝑎 和 𝑏 的素因数分解是:

$$
\huge
a=p_1^{a_1}p_2^{a_2}...p_n^{a_n}
$$

$$
\huge
b=p_1^{b_1}p_2^{b_2}...p_n^{b_n}
$$

其中每个指数都是非负整数，且两个素因数分解中出现的所有素数都包含在两者中.

8#### 1.2.3.2 欧几里得算法、辗转相除法

其基于的理念是，当 𝑎 ≥ 𝑏 且 𝑐 = 𝑎 mod 𝑏，则 $gcd(𝑎, 𝑏) = gcd(𝑏, 𝑐)$.

#### 1.2.3.3 求贝祖系数

**两步法**
- 第 1 步：使用欧几里得算法求解最大公约数
- 第 2 步：通过回代将最大公约数表示为原始两个数的线性组合

**扩展欧几里得算法**
求满足 $𝑥𝑎 + 𝑦𝑏 = gcd(𝑎, 𝑏)$ 的𝑥和𝑦，假设𝑎 ≥ 𝑏
由于

$$
\huge
gcd (a, b) = gcd(b, a\ mod\ b)
$$

存在𝑥' 和𝑦' 满足

$$
\huge
𝑥'𝑏 + 𝑦'( 𝑎\ mod\ 𝑏) = gcd(𝑏, 𝑎\ mod\ 𝑏)
$$

### 1.2.4 最小公倍数

**定义**：正整数 𝑎 和 𝑏 的最小公倍数是同时能被𝑎和𝑏整除的最小正整数，记作 $lcm(a, b)$. 最小公倍数也可以通过素因数分解来计算.

$$
\huge
lcm(a,b)=p_1^{max(a_1,b_1)}p_2^{max(a_2,b_2)}...p_n^{max(a_n,b_n)}
$$

**定理**: 若𝑎, 𝑏为正整数，则 $ab = gcd(a, b) \cdot lcm(a, b)$

### 1.2.5 和素数有关的各项定理

**素数测试及试除法**
- **定理**：$若a是合数, 则a必有小于或等于\sqrt a的因子.$
- **试除法**：$依次将\leq \sqrt a的素数除a来判断a是否素数$

**埃拉托斯特尼筛法**

**无穷素数**
- **定理**: 素数的个数是无限的.

**梅森素数**
- **定义**: 形如 $2^p-1$ 的素数 , 且 𝑝 是素数，被称为梅森素数（Mersenne primes）
- 截至 2024 年 10 月，已知 52 个梅森素数，其中最大的一个是 $2^{136279841} − 1$ ，它有近 4100 多万个十进制数字

**素数定理（Prime Number Theorem）**
- $不超过 x 的素数个数与 x/ ln x的比率随着 x 的增大而趋近于 1$
- 没有一个简单的函数 𝑓(𝑛) 使得 𝑓(𝑛) 对所有正整数 𝑛 都为素数

### 1.2.6 关于素数的猜想

**哥德巴赫猜想**：每个大于 2 的偶整数 𝑛 都是两个素数之和。该猜想已经通过计算机验证了所有不超过 $1.6\cdot 10^{18}$ 的正偶整数。多数数学家相信这一猜想是正确的.
**孪生素数猜想**：孪生素数猜想认为存在无穷多对孪生素数。孪生素数是指相差 2 的素数对。例子包括 3 和 5，5 和 7，11 和 13 等。

### 1.2.7 互素

**定义**：如果两个整数 𝑎 和 𝑏 的最大公约数为 1，则称 𝑎 和 𝑏 互素.
**定义**：我们称 $a_1, a_2, ⋯ , a_n$,两两互素当 $gcd(a_i, a_j) = 1$ 对于任意 1 ≤ 𝑖 < 𝑗 ≤ 𝑛都成立

### 1.2.8 同余式除以整数

**定理** : $设 𝑚 为正整数，𝑎、𝑏 和𝑐为整数. 若 𝑎𝑐 ≡ 𝑏𝑐 (mod\ 𝑚) 且 gcd(𝑐, 𝑚) = 1, 则𝑎 ≡ 𝑏 (mod\ 𝑚).$

## 1.3 求解同余方程

### 1.3.1 线性同余式

**定义**：形如 $𝑎𝑥 ≡ 𝑏(mod\  𝑚)$ 的同余式，其中 𝑚 为正整数，𝑎 和 𝑏 是整数，𝑥 是变量，称为线性同余式

### 1.3.2 逆元

**定义**：若整数 $\bar a$ 满足 $a\bar a ≡ 1\ mod\ m$ ，则称 $\bar a$ 为𝑎模 𝑚 的逆元.
**定理 1**：若𝑎和𝑚是互素的整数且 𝑚 > 1 ，则 𝑎 在模 𝑚 下有唯一逆元。

#### 求解逆元通用解法

**目标**：求解 𝑎 在模 𝑚 下的逆元：
- 步骤 1：利用 (扩展) 欧几里得算法求解 $𝑥𝑎 + 𝑦𝑚 = gcd(𝑎, 𝑚) = 1$
- 步骤 2：两边同时模 $m$，可得 $𝑥𝑎 ≡ 1 (mod\ 𝑚)$

### 1.3.3 用逆元求解线性同余式

通过两边同时乘以 $\bar 𝑎$ 来解方程 $𝑎𝑥 ≡ 𝑏(mod\ 𝑚)$

### 1.3.4 中国剩余定理

有若干物， 其数未知。除以 3，余数为 2；除以 5，余数为 3；除以 7，余数为 2。这些物的数量是多少？

这个谜题可以被转化为解以下同余方程组的问题:

$$
\huge
\begin{cases}
𝑥 ≡ 2 ( mod\ 3)\\
𝑥 ≡ 3 ( mod\ 5)\\
𝑥 ≡ 2 ( mod\ 7)\\
\end{cases}
$$

![[001 数论和密码学(中文)-完整.pdf#page=89&rect=37,16,696,465|001 数论和密码学(中文)-完整, p.89]]

**定理 2: (The Chinese Remainder Theorem)** $设 𝑚_1, 𝑚_2, … , 𝑚_𝑛是两两互素且大于 1 的正整数，𝑎_1, 𝑎_2, … , 𝑎_𝑛 是任意整数. 以下同余方程组$

$$
\huge
\begin{matrix}
𝑥 ≡ 𝑎_1 (mod\ 𝑚_1)\\
𝑥 ≡ 𝑎_2 (mod\ 𝑚_2)\\
\cdot\\
\cdot\\
\cdot\\
𝑥 ≡ 𝑎_𝑛 (mod\ 𝑚_𝑛)\\
\end{matrix}
$$

$有唯一的解模 𝑚 = 𝑚_1𝑚_2 … 𝑚_𝑛.$

$(即存在一个解 𝑥，使得 0 ≤ 𝑥 < 𝑚，且所有其他解与该解模 m 同余.)$

**求解过程：**

$$
\huge
\begin{cases}
𝑥 ≡ a_1 ( mod\ m_1)\\
𝑥 ≡ a_2 ( mod\ m_2)\\
\cdot\\
\cdot\\
\cdot\\
𝑥 ≡ a_n ( mod\ m_n)\\
\end{cases}
$$

- 步骤 1. $计算所有模数的积：m = m_1m_2 ⋯ m_n,$
- 步骤 2. $针对每个同余方程 𝑥 ≡ 𝑎𝑘 (mod\ 𝑚_k)，$
	- a. $计算 𝑀_k = 𝑚/𝑚_k$
	- b. $利用（扩展）欧几里得算法计算𝑀_k在模𝑚_𝑘下的逆元，记为𝑀_k^{-1}.$
- 步骤 3. $x=(\sum\limits_{i=1}^{n} a_iM_iM_i^{-1} )mod\ m$

### 1.3.5 回代法

**将每个同余方程转化为等式，代入变量的值到另一个同余方程中，并持续进行这个过程，直到解决所有同余方程**
![[001 数论和密码学(中文)-完整.pdf#page=96&rect=24,69,699,353|001 数论和密码学(中文)-完整, p.96]]

### 1.3.6 Wilson 定理

$𝑝是素数当且仅当 (𝑝 − 1)! ≡ −1(mod\ 𝑝)$

### 1.3.7 欧拉函数与欧拉定理

**欧拉函数𝜑(𝑛)**：比𝑛小且与𝑛互质的正整数的个数. 例：𝜑(6) = 2 \[1, 5]; 𝜑(7) = 6 \[1, 2, 3, 4, 5, 6]
**欧拉定理**：$若 gcd(𝑎, 𝑛) = 1，则𝑎^{𝜑(n)} ≡ 1 (mod\ 𝑛).$
**欧拉定理推论**：$若 gcd(𝑎, 𝑛) = 1，则𝑎^{xmod\ 𝜑(n)} ≡ 𝑎 (mod 𝑛).$

### 1.3.8 费马小定理

**定理 3**：$如果 𝑝 是一个素数且 𝑎 是一个不被 𝑝 整除的整数， 则有 𝑎^{p-1} ≡ 1\ (mod\ 𝑝)$

### 1.3.9 伪素数

给定一个正整数 𝑛，如果 $2n-1 ≡ 1 (mod\ n)$:

- 若𝑛不满足该同余方程，则𝑛是合数.
- 若𝑛满足该同余方程，则𝑛可能是素数，也可能是基数 2 的伪素数

### 1.3.10 原根

**定义**：一个素数 𝑝 的原根是指： $ℤ_p中的一个整数 𝑟，使得 ℤ_p中的每一个非零元素都是 𝑟 的某个幂$
**重要事实**：对于每个素数 𝑝，总存在一个原根

### 1.3.11 离散对数

假设 𝑝 是一个素数，𝑟 是模 𝑝 的一个原根。若 𝑎 是一个位于 1 和 𝑝−1 之间的整数，

即 𝑎 是 $ℤ_p$ 的一个元素，则存在一个唯一的指数 𝑒 使得 $𝑟^e = 𝑎$ 在 $ℤ_p$ 中成立，也即 $𝑟^e\ mod\ 𝑝 = 𝑎$.

定义：设 𝑝 是一个素数，𝑟 是模 𝑝 的一个原根，且 𝑎 是位于 1 到 𝑝−1 之间的整数。若 $𝑟^e\ mod\ 𝑝 = 𝑎$，且 1 ≤ 𝑒 ≤ 𝑝 − 1，我们称 𝑒 为模 𝑝 以 𝑟 为底数的 𝑎 的离散对数， 写作 $log_r 𝑎 = 𝑒$ (其中素数𝑝是默认的).

## 1.4 同余式的应用

### 1.4.1 哈希函数

**定义**: 哈希函数 ℎ 将具有键 𝑘 的记录分配到存储位置 ℎ(𝑘).
一个常见的哈希函数是 $ℎ(𝑘) = 𝑘\ mod\ 𝑚$，其中 𝑚 是存储位置的总数.

### 1.4.2 伪随机数

线性同余法是生成伪随机数的一种常用方法.

- 生成伪随机数需要四个整数：模数 𝑚、乘数 𝑎、增量 𝑐、以及种子 $𝑥_0$, 其中 $2\ ≤\ 𝑎\ <\ 𝑚,\ 0\ ≤\ 𝑐\ <\ 𝑚,\ 0\ ≤\ 𝑥_0\ <\ 𝑚.$
- 我们通过以下递归定义的函数生成伪随机数序列 $\{𝑥_𝑛\}$: $𝑥_{n+1} = (𝑎𝑥_n + 𝑐) mod 𝑚$
若需介于 0 和 1 之间的伪随机数，可将生成的数字除以模数， 即 $𝑥_𝑛 /𝑚$

## 1.5 密码学

### 其他的太简单这里只写 RSA 密码系统

### 1.5.1 RSA 密码系统

设𝑝和𝑞是两个不相等的大素数，𝑛 = 𝑝𝑞。

选择一个与 𝜑(𝑛) 互素的正整数 𝑤，并设 𝑑 为 𝑤 在模𝜑(𝑛) 下的逆

- 加密秘钥：𝑤 和 𝑛
- 解密秘钥：𝑑 和 𝑛
- 需保密数据：𝑝，𝑞，𝜑(𝑛) ，𝑑
设 𝑚 是待加密数据块，且𝑚 < 𝑛：
- 加密算法：$𝑐 = 𝐸 (𝑚) = 𝑚^w\ mod\ 𝑛$
- 解密算法：$𝐷 (𝑐) = 𝑐^d\ mod\ 𝑛$

### 1.5.2 加密协议：密钥交换

密钥交换是一种加密协议：双方可在没有任何过去共享秘密信息的情况下， 通过不安全的通道交换一个秘密密钥。

下面通过示例描述了 Diffie-Hellman 密钥协议.

1. 假设 Alice 和 Bob 希望共享一个共同的密钥.
2. Alice 和 Bob 同意使用一个素数𝑝和𝑝的一个原根𝑎.
3. Alice 选择一个秘密整数𝑘1，并将 $𝑎^{𝑘1}\ mod\ 𝑝$ 发送给 Bob.
4. Bob 选择一个秘密整数𝑘2，并将 $𝑎^{𝑘2}\ mod\ 𝑝$ 发送给 Alice.
5. Alice 计算 $(𝑎^{𝑘2} )^{𝑘1}$ mod 𝑝.
6. Bob 计算 $(𝑎^{𝑘1})^{𝑘2}$ mod 𝑝.
在协议结束时， Alice 和 Bob 都有他们的共享密钥 (𝑎𝑘2)𝑘1 mod 𝑝 = (𝑎𝑘1)𝑘2 mod 𝑝

### 1.5.3 数字签名

Bob 为确保收到的消息来自 Alice

- Alice 使用解密函数加密，发送 $c=D_{(n,d)}(m)$
- Bob 使用加密函数解密，得到 $m'=E_{(n,w)}(c)$
若 $m'=m$，则可以确信消息来自 $Alice$

### 1.5.4 同态加密

**定义** **全同态加密**指对密文经行操作等价于对明文经行操作，即满足性质

$$
\huge
\huge E((m_1+m_2)\times m_3)=(E(m_1)+E(m_2))\times E(m_3)
$$

**部分同态加密**即只对某些运算同态
- **加法同态**：

$$
\huge E(m_1+m_2)=E(m_1)+E(m_2)
$$

- **乘法同态**：

$$
\huge E(m_1\times m_2)=E(m_1)\times E(m_2)
$$

> RSA 密码系统是乘法同态，非加法同态

### 1.5.5 Schnorr ZKP 零知识证明协议

证明者向验证者证明其知晓离散对数，但不透露具体值：

选取一个素数 $p$ 及其原根 $g$，证明者有私钥 $x<p$，公钥 $y=g^x\mod{p}$，重复 $n$ 轮以下操作：

- 证明者随机选取一个小于 $p$ 的整数 $r$，发送 $a=g^r\mod p$
- 验证者发送一个随机值 $(e=0或1)$
- 证明者发送 $s=(r+ex)\mod{(p-1)}$
- 验证者验证 $g^s=ay^e\mod p$ 是否成立

> 重复 $n$ 轮下，若证明者不知道离散对数，则验证成功率为 $\left(\frac{1}{2}\right)^n$

## 1.6 余数系统

### 定义

利用中国剩余定理，可以将一个大整数表示为元组

**定义** 大整数 $x$ 在余数系统下可表示为

$$
\huge x=(x_1|x_2|\cdots|x_k)\text{RNS}(p_1|p_2|\cdots|p_k)
$$

其中

$$
\huge x_i=x\mod p_i
$$

且对任意 $i,j$，有 $p_i,p_j$ 互素

### 运算

$$
\large x+y=((x_1+y_1)\mod p_1|(x_2+y_2)\mod p_2|\cdots(x_k+y_k)\mod p_k)
$$

$$
\large x\times y=((x_1\times y_1)\mod p_1|(x_2\times y_2)\mod p_2|\cdots(x_k\times y_k)\mod p_k)
$$

# 第二章 组合计数基础

## 2.1 鸽巢原理

**定理** 将 $k+1$ 个物体放入 $k$ 个盒子中，则至少有一个盒子包含两个或更多物体

**广义鸽巢原理** 将 $N$ 个物体放入 $k$ 个盒子中，则至少有一个盒子包含至少 $\lceil N/k\rceil$ 个物体

## 2.2 排列组合

**定义** 对于 $n$ 个不同元素的集合，其 $r$- 排列的数量为

$$
\huge P(n,r)=\dfrac{n!}{(n-r)!}
$$

**定义** 对于 $n$ 个不同元素的集合，其 $r$- 组合的数量为

$$
\huge C(n,r)或\binom{n}{r}=\dfrac{n!}{r!(n-r)!}
$$

### 组合证明

组合证明指使用以下方法之一来证明恒等式：

- **双计数证明**：使用计数论证来证明恒等式两边以不同的方式计算相同的对象
- **双射证明**：展示恒等式两边所计数的对象集合之间存在双射关系

#### 二项式定理

$$
\huge (x+y)^n=\sum_{k=0}^{n}\binom{n}{k}x^{n-k}y^k
$$

#### 帕斯卡恒等式

$$
\huge \binom{n+1}{k}=\binom{n}{k}+\binom{n}{k-1}
$$

## 2.3 广义排列组合

### 2.3.1 带有重复对象的排列组合

| 类型      | 是否允许重复 | 公式                       |
| ------- | ------ | ------------------------ |
| $r$- 排列 | 否      | $\huge P(n,r)$           |
| $r$- 组合 | 否      | $\huge\binom{n}{r}$      |
| $r$- 排列 | 是      | $\huge n^r$<br>          |
| $r$- 组合 | 是      | $\huge \binom{n+r-1}{r}$ |

### 2.3.2 带有不可区分对象的排列

**定理** $n$ 个对象分为 $k$ 类，每类分别有 $n_1,n_2,…,n_k$ 个对象，不同的排列数量是

$$
\huge \dfrac{n!}{n_1!n_2!\cdots n_k!}
$$

> 这里的不可区分指的是同一类中的不可区分

### 2.3.3 将对象分配到盒子中

| $n$ 物体是否可区分 | $k$ 盒子是否可区分 | 公式                                      |
| ----------- | ----------- | --------------------------------------- |
| 是           | 是           | $\huge \dfrac{n!}{n_1!n_2!\cdots n_k!}$ |
| 否           | 是           | $\huge \binom{n+k-1}{k}$                |
| 是           | 否           | 无简单封闭公式                                 |
| 否           | 否           | 无简单封闭公式                                 |

> 这里的区分指的是所有物体或盒子之间的区分

## 2.4 母函数

**定义** 对于序列 $a_0,a_1,a_2,…$，函数

$$
\huge G(x)=a_0+a_1x+a_2x^2+\cdots
$$

称为序列的**母函数**

> 母函数利用多项式乘法的过程来模拟**组合**

母函数是这样一种方法，对于对象 $k$，其母函数的指数为所有可能的选取的个数，各项系数为该选取下对应的方法数。将所有对象的母函数乘起来，得到的描述所有对象做**组合**的状态空间。

**例** 有 8 个白球和 5 个黑球，要求选取偶数个白球和不少于两个黑球，有多少组合方式
**解**
白球的母函数为

$$
\huge G_w(x)=1+x^2+x^4+x^6+x^8
$$

黑球的母函数为

$$
\huge G_b(x)=x^2+x^3+x^4+x^5+x^6
$$

取乘积

$$
\huge G=G_w(x)G_b(x)
$$

其中 $x^k$ 的系数即为 $k$ 个球的组合的方法数

**例** 若上例中白球不可区分，则有多少组合方式
**解**
白球母函数改写为

$$
\huge G_w(x)=\binom{8}{0}+\binom{8}{2}x^2+\cdots+\binom{8}{8}x^8
$$

### 2.4.1 整数拆分

多项式相乘时指数相加，利用指数来表征整数的组合

#### 2.4.1.1 无序拆分

**例** 整数 $a_1,a_2,…,a_n$ 分别有 $k_1,k_2,…,k_n$ 个，求整数 $N$ 有几种拆分方式
**解**
整数 $a_i$ 对应的母函数为

$$
\huge G_i(x)=1+x^{a_i}+x^{2a_i}+\cdots+x^{k_ia_i}=\dfrac{1-x^{(k_i+1)a_i}}{1-x^{a_i}}
$$

若 $a_i$ 有无穷个，则

$$
\huge G_i(x)=\dfrac{1}{1-x^{a_i}}
$$

将所有母函数相乘

$$
\huge G(x)=\prod_{i=1}^n{G_i(x)}
$$

其中 $x^N$ 的系数即为 $N$ 的拆分方式数

#### 2.4.1.2 有序拆分

**例（定项拆分）** 将 $N$ 有序拆分为 $r$ 个非 $0$ 部分
**解**
**方法 1（隔板法）** 这相当于在 $N$ 个球中插入 $r-1$ 个隔板，结果为 $\binom{N-1}{r-1}$
**方法 2（母函数）**
每个部分的数对应的母函数为

$$
\huge G_i(x)=x+x^2+\cdots=\dfrac{x}{1-x}
$$

相乘得

$$
\huge G(x)=x^r(1-x)^{-r}=x^r\sum_{k=0}^{\infty}\binom{r+k-1}{r-1}x^k
$$

令 $k+r=N$，有

$$
\huge G(x)=\sum_{N=r}^{\infty}\binom{N-1}{r-1}x^N
$$

**例（不定项拆分）** 将 $N$ 有序拆分的方法数
**解**
只需将 $N$ 的 $r$- 拆分累加即可

$$
\huge \sum_{r=1}^N\binom{N-1}{r-1}=\sum_{j=0}^{N-1}\binom{N-1}{j}=2^{N-1}
$$

**例** 将 $N$ 有序拆分为无限个整数 $a_1,a_2,…,a_n$ 的和
**解**
母函数为

$$
\huge G=1+(x^{a_1}+x^{a_2}+\cdots+x^{a_n})+(x^{a_1}+x^{a_2}+\cdots+x^{a_n})^2+\cdots
$$

### 2.4.2 指数型母函数

**定义** 对于序列 $a_0,a_1,a_2,…$，函数

$$
\huge G_e(x)=a_0+\dfrac{a_1}{1!}x+\dfrac{a_2}{2!}x^2+\cdots
$$

称为序列的**指数型母函数**

> 用于解决从分为 $k$ 类的对象中做 $r$-**排列**的问题

**例** 现有 $n$ 个元素 $a_1,a_2,…,a_n$，分别重复 $k_1,k_2,…,k_n$ 次，对其做 $r$- 排列
**解**
$a_i$ 对应的指数型母函数为

$$
\huge G_{ei}(x)=1+\dfrac{x}{1!}+\dfrac{x^2}{2!}+\cdots+\dfrac{x^{k_i}}{k_i!}
$$

若 $a_i$ 有无穷个，则

$$
\huge G_{ei}(x)=e^x
$$

其 $r$- 排列的母函数为

$$
\huge G_e(x)=\prod_{i=1}^nG_{ei}(x)
$$

其中，$\dfrac{x^r}{r!}$ 对应的系数为 $r$- 排列的方法数

**例** 由 $1,2,3,4,5$ 组成 $n$ 位数，其中 $2,4$ 出现偶数次
**解**
指数型母函数为

$$
\huge\begin{align}

G_e(x)&=\left(1+\dfrac{x^2}{2!}+\dfrac{x^4}{4!}+\cdots\right)^2\left(1+\dfrac{x}{1!}+\dfrac{x^2}{2!}+\cdots\right)^3\\

&=\left(\dfrac{e^x+e^{-x}}{2}\right)^2e^{3x}\\

&=\dfrac{1}{4}(e^{5x}+2e^{3x}+e^x)\\

&=\sum_{n=0}^\infty\dfrac{1}{4}(5^n+2\cdot3^n+1)\dfrac{x^n}{n!}

\end{align}
$$

即 $n$ 位数有 $a_n=\dfrac{1}{4}(5^n+2\cdot3^n+1)$ 种可能

# 第三章 高级计数技术

## 3.1 递归关系的应用

### 3.1.1 递归关系

> **定义**：$数列\{ a_n\} 的递归关系是一个方程，它将a_n 表示为该数列之前的一个或多个项的函数，即a_1, a_1, …,a_{n-1},其中𝑛为所有满足n ≥ n_0 的整数，n_0 是一个非负整数.$
> 1. 如果一个数列的各项满足递归关系，则称该数列为递归关系的解.
> 2. 数列的初始条件指定了递归关系生效前的各项.

#### 3.1.1.1 斐波那契数列

> **问题**
> 一对年轻的兔子（一公一母）被放置在一个岛上。兔子在满两个月前不会繁殖。两个月大后，每对兔子每个月都会产下一对兔子。假设兔子永远不会死亡，求在经过𝑛 个月后岛上兔子的对数的递归关系.

> **解答**
> 数列 $\{f_n\}$ 满足递归关系 $f_n = f_{n-1}+f_{n-2}$，适用于𝑛 ≥ 3 ，初始条件为 $f_1 = 1$ 和 $f_2 = 1$。𝑛 个月后岛上的兔子对数由第𝑛 个斐波那契数给出.

#### 3.1.1.2 汉诺塔问题

> **规则**：你可以一次移动一个圆盘，从一个柱子移动到另一个柱子，只要大的圆盘永远不会放在小的圆盘上面.
> **目标**：通过允许的移动，将所有圆盘最终放在第二个柱子上，按大小顺序排列，最大的在底部.

> **解答**：初始时，n 个圆盘在柱子 1 上。我们可以将顶部的 n−1 个圆盘按照谜题规则移动到柱子 3，这需要 $H_{n−1}$ 次移动。我们使用 1 次移动将最大的圆盘转移到第二个柱子。然后，我们将 n−1 个圆盘从柱子 3 移到柱子 2，需要额外的 $H_{n−1}$ 次移动。这个过程不能用更少的步骤完成。因此，

$$
\huge H_n=2H_{n-1}+1
$$

### 3.1.2 各种递归关系的例子

- $Pn = (1.11)P_{n-1}$ 一阶线性齐次递归关系的形式
- $f_n = f_{n-1} + f_{n-2}$ 二阶线性齐次递归关系的形式
- $a_n=a_{n-1}+a_{n-2}^2$ 非线性
- $H_n = 2H_{n−1} + 1$ 非齐次
- $B_n = nB_{n−1}$ 系数不是常数

## 3.2 线性递归关系的求解

### 3.2.1 齐次递归关系

> **定义**：一个具有常系数的 k 阶线性齐次递归关系的形式为 $\large a_n= c_1a_{n−1} + c_2a_{n−2} + … + c_k a_{n−k}$ ,其中 $\large c_1, c_2, ….,c_k$ 为实数，且 $\large c_k ≠ 0$

#### 3.2.1.1 二阶无重根

设 $c_1$ 和 $c_2$ 为实数。假设方程 $\large r^2 – c_1r – c_2 = 0$ 有两个不同的根 $r_1$ 和 $r_2$ 。则数列{$a_n$}是递归关系的解

$$
\huge
a_n=c_1a_{n-1}+c_2a_{n-2}
$$

当且仅当

$$
\huge
a_n=\alpha_1r_1^n+\alpha_1r_2^n
$$

对于 $n = 0,1,2,…$ 成立，其中 $\alpha_1$ 和 $\alpha_2$ 是常数。

#### 3.2.1.2 二阶有重根

设 $c_1$ 和 $c_2$ 为实数且 $c_2 ≠ 0$ 。假设方程 $\large r^2 –c_1r – c_2 = 0$ 有一个重复根 $r_0$ 。那么数列{$a_n$}是递归关系 $\large a_n = c_1a_{n−1} + c_2a_{n−2}$ 的解，当且仅当

$$
\huge 
a_n=\alpha_1r_0^n+\alpha_2nr_0^n
$$

对于 $n = 0,1,2,…$ 成立，其中 $\alpha_1$ 和 $\alpha_2$ 是常数。

#### 3.2.1.3 任意阶

**定理** 对于 $k$ 阶常系数齐次递归关系

$$
\huge c_0a_n+c_1a_{n+1}+c_{2}a_{n+2}+\cdots+c_{k}a_{n+k}=0
$$

定义其特征方程为

$$
\huge c_kr^k+\cdots+c_{1}r+c_0=0
$$

若方程有 $t$ 个根 $r_1,…,r_t$ 且重数为 $\alpha_1,…,\alpha_t$，则数列通项为

$$
\huge \begin{align}
a_n=&(C_{11}+C_{12}n+\cdots+C_{1\alpha_1}n^{\alpha_1-1})r_1^n+\\
&(C_{21}+C_{22}n+\cdots+C_{2\alpha_2}n^{\alpha_2-1})r_2^n+\\
&\cdots\\
&(C_{t1}+C_{t2}n+\cdots+C_{t\alpha_t}n^{\alpha_t-1})r_t^n\\
=&\sum_{i=1}^{t}\left(\sum_{j=1}^{\alpha_i}C_{ij}n^{j-1}\right)r_i^n
\end{align}
$$

其中 $C_{ij}$ 为待定系数

### 3.2.2 非齐次递归关系

#### 3.2.2.1 带有常系数的线性非齐次递归关系

**定义**：带有常系数的线性非齐次递归关系的形式为:

$$
\huge
a_n = c_1a_{n−1} + c_2a_{n−2} + ….. + c_k a_{n−k} + F(n) 
$$

其中 $c_1, c_2, ….,c_k$ 是实数， $F(n)$ 是不全为零的函数，仅依赖𝑛.

递归关系

$$
\huge
a_n = c_1a_{n−1} + c_2a_{n−2} + ….. + c_k a_{n−k} 
$$

称为**关联的齐次递归关系**.

**定理**：
如果 $\large \{a_n^{(p)}\}$ 是具有常系数的非齐次线性递归关系的一个特解

$$
\huge 
a_n=c_1a_{n-1}+c_2a_{n-1}+...+c_ka_{n-k}+F(n)
$$

那么每个解的形式为 $\large \{a_n^{(p)} + a_n^{(h)}\}$，其中 $\large \{a_n^{(h)}\}$ 是关联的齐次递归关系的解

$$
\huge
a_n = c_1a_{n-1}+c_2a_{n-1}+...+c_ka_{n-k}
$$

## 3.3 分治算法与递归关系

### 3.3.1 分治算法与递归关系

**定义**：分治算法通过首先将一个问题划分为一个或多个相同问题的小规模实例，然后利用这些较小问题的解来解决原始问题.
假设一个递归算法将一个规模为𝑛的问题划分为𝑎个子问题.每个子问题的规模为 $n/b$.
假设在合并步骤中需要𝑔(𝑛) 次额外操作.
则解决规模为𝑛的问题所需的操作数𝑓(𝑛) 满足以下递归关系:

$$
\huge 
f (n) = af (n / b) + g (n)
$$

这被称为分治递归关系.

### 3.3.2 例子

#### 3.3.2.1 二分查找

二分查找将对大小为𝑛的序列中的元素的搜索问题减少到对大小为 $\large n/2$ 的序列中的搜索。实现这种减少需要两个比较;

- 一个比较用于确定序列是否包含元素
- 另一个比较用于决定是搜索序列的上半部分还是下半部分
因此，如果 $\large 𝑓(𝑛)$ 是在大小为 $\large n$ 的序列中查找一个元素所需的比较次数，那么满足的递归关系是

$$
\huge
f (n) = f (n / 2) + 2
$$

当𝑛是偶数.

#### 3.3.2.2 归并排序

归并排序算法将一个规模为 $\large n$（假设 $\large n$ 是偶数）的列表分成两个规模为 $\large n/2$ 的子列表。它使用少于 $\large n$ 次比较来合并这两个已排序的列表.

因此，排序一个规模为 $\large n$ 的序列所需的比较次数 $\large M(n)$ 满足以下递归关系

$$
\huge 
M (n) = 2M (n / 2) + n
$$

#### 3.3.2.3 整数快速乘法

两个 $\large 2n$ 位整数的乘法可以通过三个 $\large n$ 位整数的乘法以及加法、减法和移位来完成。因此，如果 $\large f(n)$ 是乘两个 $\large n$ 位整数所需的总操作数，则

$$
\huge
f (2n) = 3 f (n) +Cn
$$

其中 $\large Cn$ 表示总的位操作数；这些加法、减法和移位是 $\large n$ 位操作的常数倍

### 3.3.3 估算分治算法函数的大小

#### 定理 1：

设𝑓(𝑛) 是一个递增函数，满足递归关系

$$
\huge
f(n) = a \cdot f(n/b) + c
$$

其中 $\large n$ 是 $\large b$ 的倍数，$\large a \geq 1$，$\large b$ 是大于 1 的整数，$\large c$ 是一个正实数.

那么

$$
\huge
f(x) = \left\{ 
\begin{array}{cl} 
O(n^{\log_b{a}}) & \text{若 } a>1 \\
O(\log_b{n}) & \text{若 } a=1 
\end{array} 
\right.
$$

更进一步，

$$
\huge
f(x) = \left\{ 
\begin{array}{cl} 
\left(f(1)+\frac{c}{a-1}\right)n^{\log_b{a}}-\frac{c}{a-1} & \text{若 } a>1 \\
f(1)+c\log_b{n} & \text{若 } a=1 
\end{array} 
\right.
$$

#### 定理 2：

主定理（Master Theorem）：设𝑓(n) 是一个递增函数，满足递归关系

$$
\huge
f (n) = af (n / b) + cn^d
$$

当 $\large n = bk$, $\large k$ 为大于 1 的正整数, $\large c$ 为正实数，$\large d$ 为非负实数。

可具体化为

$$
\huge
f(x) = \left\{ 
\begin{array}{cl} 
O\left(n^d\right) & \text{若 } a<b^d \\
O\left(n^d\log{n}\right) & \text{若 } a=b^d \\
O\left(n^{\log_b{a}}\right) & \text{若 } a>b^d
\end{array} 
\right.
$$

## 3.4 容斥原理

**定理** 设 $A_1,A_2,…,A_n$ 为有限集，则

$$
\huge\begin{align}
|A_1\cup A_2\cup\cdots\cup A_n|=&\sum_{1\leq i\leq n}|A_i|-\sum_{1\leq i\leq j\leq n}|A_i\cap A_j|+\\
&\sum_{1\leq i\leq j\leq k\leq n}|A_i\cap A_j\cap A_k|-\cdots+\\
&(-1)^{n-1}|A_1\cap A_2\cap\cdots\cap A_n|
\end{align}
$$

# 第四章 命题逻辑

## 4.1

# 第五章 谓词逻辑
